% \iffalse meta-comment
% Copyright (C) 2009 by Martin Scharrer <martin@scharrer-online.de>
% http://www.scharrer-online.de/latex/
% -----------------------------------------------------------------
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Martin Scharrer.
%
% This work consists of the file rcs-multi.dtx and the derived file 
% rcs-multi.sty.
% $Id$
% \fi
% \iffalse
%<*package|driver|wrapper>
\def\filedate$#1: #2 #3 #4-#5-#6 #7 ${%
 \year#4\month#5\day#6\relax
 \def\filedate{#4/#5/#6}%
 \def\filerev{#3}%
}
\filedate$Id$
\def\fileversion{v0.1}
%</package|driver|wrapper>
%<*driver>
\ProvidesFile{rcs-multi.dtx}
 [\filedate\space\fileversion\space RCS Keywords for multi-file LaTeX documents]

\documentclass{ltxdoc}
\usepackage{rcs-multi}
\usepackage{booktabs}
\usepackage{ifpdf}
\ifpdf
  % use hypdoc if you have it, hyperref else
  \IfFileExists{hypdoc.sty}
    {\usepackage{hypdoc}}
    {\usepackage{hyperref}}
\else
  \let\url\texttt
\fi
\usepackage{xspace}
\newcommand{\ie}{i.e.\@\xspace}
\newcommand{\eg}{e.g.\@\xspace}

\iffalse
\let\css=\cs
\let\op=\cs
\let\DescribeOption\DescribeMacro
\let\DescribeScript\DescribeOption
\else % crossreference of macros in documentation
\makeatletter

\usepackage{xspace}
\@namedef{seen@package@latex}{1} %^^A avoid footnotes for 'latex'
\newcommand*{\pkg}[1]{%
  \href{http://tug.ctan.org/pkg/#1}{\texttt{#1}}%
  % URL footnote (for print-out) on first appearance:
  \@ifundefined{seen@package@#1}{%
    \footnote{CTAN: \url{http://tug.ctan.org/pkg/#1}}%
    \@namedef{seen@package@#1}{1}%
  }{}%
  \xspace
}
\newcommand*{\rcsmulti}{%
  \texttt{rcs-multi}\xspace%
}

% link \cs to macro definitions
\let\origmacro\macro
\let\origendmacro\endmacro
\let\origStopEventually\StopEventually
\let\origPrintDescribeMacro\PrintDescribeMacro
\usepackage{xcolor}
\definecolor{darkred}{rgb}{0.333.0.0,0.0}
\hypersetup{colorlinks=true,linkcolor=darkred,urlcolor=darkred}
\definecolor{macrodesccolor}{rgb}{0.0,0.0,0.8}
\definecolor{macroimplcolor}{rgb}{0.0,0.0,0.4}
\definecolor{metacolor}{rgb}{0.0,0.4,0.4}
\definecolor{scriptcolor}{rgb}{0.2,0.6,0.2}
\definecolor{optioncolor}{rgb}{0.3.0.2,0}

\let\macroline\\
\newlength{\macrosep}
\setlength{\macrosep}{-3em}
\renewcommand{\meta@font@select}{\color{metacolor}\itshape}
\newcommand{\macroformat}[1]{\textbf{\ttfamily #1}}
\newcommand{\optionformat}[1]{\textbf{\sffamily #1}}
\newcommand{\scriptformat}[1]{\textbf{\ttfamily #1}}
\newcommand{\macroargformat}[1]{\texttt{#1}}
\newcommand{\scriptargformat}[1]{\textbf{#1}}
\newcommand{\macrohlinkprefix}{desc}
\newcommand{\macrolink}{}

\usepackage[T1]{fontenc}
\usepackage{lmodern}

\def\DescribeMacro{\@ifnextchar*{\DescribeMacroS}{\DescribeMacroN}}
\def\DescribeMacroN{%
  \bigskip\pagebreak[3]\par\noindent\DescribeMacroS*%
}
\def\DescribeMacroS*#1#2{%
  \begingroup
  \g@namedef{href@desc@#1}{}%
  \immediate\write\@mainaux{%
    \noexpand\g@namedef{href@desc@#1}{}%
  }%
  \@ifundefined{href@impl@#1}%
    {\let\macrolink\relax}%
    {\def\macrolink{\hyperlink{impl@#1}}}%
  \hypersetup{linkcolor=macrodesccolor}%
  \hspace*{\macrosep}%
  \raisebox{\baselineskip}[\baselineskip]{\hypertarget{desc@#1}{}}%
  \macrolink{\macroformat{\textcolor{macrodesccolor}{\textbackslash #1}}}%
  \noindent\mbox{}\macroargformat{#2}\nopagebreak
  \macroline*[0.2\baselineskip]%
  \endgroup
  \nopagebreak
  \ignorespaces
}
\def\DescribeScript{\@ifnextchar*{\DescribeScriptS}{\DescribeScriptN}}
\def\DescribeScriptN{%
  \bigskip\par\pagebreak[2]\noindent\DescribeScriptS*%
}
\def\DescribeScriptS*#1#2{%
  \hspace*{\macrosep}%
  \raisebox{\baselineskip}[\baselineskip]{\hypertarget{script@#1}{}}%
  \scriptformat{\textcolor{scriptcolor}{#1}}%
  \noindent\mbox{}\scriptargformat{\ {#2}}\macroline*[0.2\baselineskip]%
  \nopagebreak
}
\def\DescribeOption{\@ifnextchar*{\DescribeOptionS}{\DescribeOptionN}}
\def\DescribeOptionN{%
  \bigskip\par\noindent\DescribeOptionS*%
}
\def\DescribeOptionS*#1{%
  \hspace*{\macrosep}%
  \raisebox{\baselineskip}[\baselineskip]{\hypertarget{option@#1}{}}%
  \optionformat{\textcolor{optioncolor}{#1}}%
  \noindent\mbox{}\macroline*[0.2\baselineskip]%
  \nopagebreak
}
\newcounter{macrolevel}
\renewenvironment{macro}[1]{%
  \addtocounter{macrolevel}{1}%
  \expandafter\macroX\expandafter{\expandafter\@gobble\string#1}%
}{%
  \addtocounter{macrolevel}{-1}%
}
\providecommand*{\g@namedef}[1]{%
  \expandafter\gdef\csname #1\endcsname
}
\newcommand*{\macroX}[1]{%
  \ifnum\c@macrolevel<2
    \smallskip
  \fi
  \par\noindent
  \g@namedef{href@impl@#1}{}%
  \immediate\write\@mainaux{%
    \noexpand\g@namedef{href@impl@#1}{}%
  }%
  \@ifundefined{href@desc@#1}%
    {\let\macrolink\relax}%
    {\def\macrolink{\hyperlink{desc@#1}}}%
  \hspace*{\macrosep}%
  \raisebox{\baselineskip}[\baselineskip]{\hypertarget{impl@#1}{}}%
  \macrolink{\macroformat{%
    \textcolor{macroimplcolor}{\textbackslash #1}}}%
  \\*[\smallskipamount]%
  \@ifnextchar\begin{\vspace*{-\baselineskip}}{\imacroarg}%
}

\newcounter{macroargs}
\newcounter{nmacroarg}

\newcommand*{\imacroarg}[1][0]{%
  \setcounter{macroargs}{#1}%
  \setcounter{nmacroarg}{1}%
  \ifnum\c@macroargs>0
    \expandafter\imacroargX
  \fi
}
\newcommand*{\aftermacroargs}{%
  \@ifnextchar\begin
    {\\*[-2ex]\ignorespaces}%
    {\\*[\smallskipamount]\ignorespaces}%
}
\newcommand*{\imacroargX}[1]{%
  \hspace*{-1em}\texttt{\#\thenmacroarg:} #1\relax
  \ifnum\c@macroargs>1
    \newline
  \fi
  \addtocounter{nmacroarg}{1}%
  \addtocounter{macroargs}{-1}%
  \ifnum\c@macroargs>0
    \expandafter\imacroargX
  \else
    \expandafter\aftermacroargs
  \fi
}


\def\karg#1{\{\$\textcolor{metacolor}{#1}\$\}}
\def\kmarg#1{\{\$\meta{#1}\$\}}

\DeclareRobustCommand{\csi}[1]{%
  \begingroup
  \hypersetup{linkcolor=macroimplcolor}%
  \renewcommand{\macrohlinkprefix}{impl}%
  \@ifundefined{href@impl@#1}%
    {\let\macrolink\relax}%
    {\def\macrolink{\hyperlink{impl@#1}}}%
  \csX{#1}%
  \endgroup
}
\DeclareRobustCommand{\csd}[1]{%
  \begingroup
  \hypersetup{linkcolor=macrodesccolor}%
  \renewcommand{\macrohlinkprefix}{macro}%
  \@ifundefined{href@desc@#1}%
    {\let\macrolink\relax}%
    {\def\macrolink{\hyperlink{desc@#1}}}%
  \csX{#1}%
  \endgroup
}
\DeclareRobustCommand{\csX}[1]{%
  \begingroup
  \macrolink{\texttt{\textbackslash#1}}%
  \endgroup
}
\let\cs\csd
\DeclareRobustCommand{\css}[1]{\texttt{\textbackslash#1}}
\DeclareRobustCommand{\op}[1]{%
  \begingroup
  \hypersetup{linkcolor=optioncolor}%
  \hyperlink{option@#1}{\textbf{\sffamily #1}}%
  \endgroup
}
\DeclareRobustCommand{\scr}[1]{%
  \begingroup
  \hypersetup{linkcolor=scriptcolor}%
  \hyperlink{script@#1}{\scriptformat{#1}}%
  \endgroup
}

\def\StopEventually#1{\origStopEventually{#1}%
\let\cs\csi
}

\fi

\usepackage{graphicx}

\EnableCrossrefs
%\DisableCrossrefs
\CodelineIndex
%\PageIndex
\RecordChanges
%\OnlyDescription
\widowpenalty=500
\clubpenalty=500
\begin{document}
  \DocInput{rcs-multi.dtx}%
  \PrintChanges
  %\clearpage
  \PrintIndex
\end{document}
%</driver>
%<*package>
% \fi
%
% \CheckSum{0}
%
% {\makeatother
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
% }
% \changes{v0.1}{2009/03/23}{Initial version forked from rcs-multi v2.0}
%
% ^^A \GetFileInfo{rcs-multi.dtx}
%
% \DoNotIndex{\newcommand,\newenvironment,\AtBeginDocument,\AtEndDocument}
% \DoNotIndex{\def,\let,\edef,\xdef,\item,\space,\write,\jobname,\relax,\!}
% \DoNotIndex{\closeout,\csname,\DeclareRobustCommand,\else,\empty,\newwrite}
% \DoNotIndex{\endcsname,\expandafter,\fi,\Hurl,\hyper@normalise,\@ifnextchar}
% \DoNotIndex{\ifnum,\@ifundefined,\ifx,\immediate,\InputIfFileExists,\ }
% \DoNotIndex{\newcount,\noexpand,\openout,\PackageWarning,\@percentchar}
% \DoNotIndex{\@sanitize,\@makeother,\@iwrcs,\%,\_,\&,\^,\$,\#,\ ,\\,\if@filesw}
% \DoNotIndex{\gdef,\begingroup,\endgroup,\catcode}
% \DoNotIndex{\^,\ ,\_,\(,\),\$,\&,\#,\@ampersamchar,\AtEndOfPackage}
% \DoNotIndex{\@backslashchar,\begin,\bgroup,\chapter,\day}
% \DoNotIndex{\DeclareOption,\do,\dospecials,\@dottedtocline,\egroup}
% \DoNotIndex{\end,\ExecuteOptions,\filedate,\fileversion,\@for}
% \DoNotIndex{\futurelet,\g@addto@macro,\global,\@gobbletwo,\hline}
% \DoNotIndex{\hspace,\if@restonecol,\if@twocolumn,\ignorespaces}
% \DoNotIndex{\makeatletter,\MakeUppercase,\@mkboth,\month,\@namedef}
% \DoNotIndex{\NeedsTeXFormat,\newif,\onecolumn,\orig@fink@prepare}
% \DoNotIndex{\orig@fink@restore,\PackageError,\ProcessOptions}
% \DoNotIndex{\ProvidesPackage,\renewcommand,\RequirePackage}
% \DoNotIndex{\@restonecolfalse,\@restonecoltrue,\section,\strut}
% \DoNotIndex{\tableofcontents,\tableofrevisions,\texttt,\today}
% \DoNotIndex{\twocolumn,\@undefined,\url,\year}
% \DoNotIndex{\textwidth,\the,\string,\raggedright,\providecommand,\small,\toks@}
% \DoNotIndex{\medskipamount,\long,\leftskip,\clearpage,\advance,\addtolength}
% \DoNotIndex{\DeclareBoolOption,\DeclareStringOption,\DeclareVoidOption}
% \DoNotIndex{\ProcessKeyvalOptions,\SetupKeyvalOptions}
% \DoNotIndex{\@firstoftwo,\@secondoftwo,\@gobble}
%
% \title{The \textsf{rcs-multi} package}
% \author{Martin Scharrer \\ \url{martin@scharrer-online.de} \\
% \url{http://www.scharrer-online.de/latex/rcs-multi}\\
% CTAN: \url{http://tug.ctan.org/pkg/rcs-multi}}
% \date{Version \expandafter\@gobble\fileversion\\[0.5ex]\today}
%
% \ifpdf
% \hypersetup{%
%   pdfauthor   = {Martin Scharrer <martin@scharrer-online.de>},
%   pdftitle    = {The rcs-multi package, \fileversion, r\filerev\ from 
%   \filedate},
%   pdfsubject  = {Documentation of LaTeX package rcs-multi which allows the 
%   typesetting of RCS keywords in multi-file LaTeX documents},
%   pdfkeywords = {rcs-multi, LaTeX, RCS, multiple files, keywords, Version 
%   Control, Id}
% }%
% \fi
% \maketitle
%
% \section{Introduction}
% This package allows to typeset version control (VC) information provided by 
% RCS\footnote{RCS homepage: \url{http://www.gnu.org/software/rcs/} 
% keywords (\eg |$||Id: ... $|) in \LaTeX\ documents which can contain of 
% multiple |.tex| files included using |\include| or |\input|.
%
% This package reads the keywords of all files and provides the VC information 
% of of the most recent changed file of the document to the user through a set 
% of macros. This information is written to the auxiliary |.aux| file during the 
% first \LaTeX\ run and read back at the next which introduces the same delay 
% known from the table of contents. The standard \LaTeX{} switch |\nofiles| can 
% be used to suppress the file generation.
%
% \subsection{Scope of Keywords}
% This package provides the RCS keyword data in two different scopes:
% document-global and file-local.
%
% \subsubsection*{Document Global}
% The document global macros, like \cs{rcsrev}, return the latest version 
% control information (keyword data) for the whole multi-file document, \ie the 
% information of the latest changed file of the document. To collect, sort and 
% provide this information is the main functionality of this package.
%
% \subsubsection*{Local to Current File}
% There are also file-local macros, \eg \cs{rcsfilerev}, which return the 
% version control information of the current file, \ie the file they are used 
% in. It is assumed here that every file using this macros calls first the macro
% \cs{rcsid}.  See section~\ref{sec:usage:id} for more details about this macro.  
% Please note that the file-local macros technically actually return the 
% \emph{last registered} information from the last \cs{rcsid}.
%
%
% \section{Usage}
% The version control information are provided by RCS keywords which
% first need to be read in by dedicated macros and can then be typeset using
% different macros.
%
% \subsection{Including RCS Keywords}\label{sec:usage:id}
% RCS keywords are included using \cs{rcsid}.  This macro should be written very 
% early in each file, \ie in the preamble of the main document soon after 
% |\documentclass| and |\usepackage{rcs-multi}| and as first in \emph{every} 
% subfile before an |\chapter| or similar macro. It does not create any output.  
% See section~\ref{sec:kwaccess} to learn how to typeset the keyword values.
%
% \DescribeMacro{rcsid}{\karg{Id}}
% \DescribeMacro*{rcsid}{\karg{Header}}
% The macro is for the |Id| keyword and must be written like shown.  A trailing 
% colon with or without spaces after the keyword name (`|Id|') is also valid but 
% \textbf{everything else} except a valid RCS string will cause a \TeX{} parse 
% error.
%
% \DescribeMacro{rcs}{\kmarg{keyword}}
% This macro let you typeset rcs keywords directly. The dollars will be stripped
% and the rest is typeset as normal text.
%
% \DescribeMacro{rcskwsave}{\kmarg{keyword}}
% This macro lets you include and save any keyword you like. The keyword can be
% already expanded or not (no value and only ``|:|'' or nothing after the key
% name). This macro is also used internally and does not create any output.
% Please note that the argument is read verbatim and that there should be no
% space between the macro and the argument's left brace.
%
%
% \subsection{Typesetting the Keyword Values}\label{sec:kwaccess}
% The following macros can be used to typeset the keyword values anywhere in the
% document. Please note that not all \LaTeX{} fonts have all special
% characters, \eg `|_|' is not provided in the standard roman font. To proper
% typeset file names and URLs containing these letters you can use either
% teletype font (|\texttt|) or use |{\urlstyle{rm}\rcsnolinkurl{...}}| which
% requires the \pkg{hyperref} package.
%
% \DescribeMacro{rcsrev}{}
% \DescribeMacro*{rcsdate}{}
% \DescribeMacro*{rcsauthor}{}
% These macros hold the keyword values of the whole document, \ie of the most
% recent revision. They can be used everywhere in every file of the \LaTeX{}
% document, after |\usepackage{rcs-multi}| of course. Please see
% section~\ref{sec:date} how to typeset parts of the date.
%
% \DescribeMacro{rcsfilerev}{}
% \DescribeMacro*{rcsfiledate}{}
% \DescribeMacro*{rcsfileauthor}{}
% These macros hold the keyword values of the current \LaTeX{} file, but only if
% it contains a \cs{rcsid} or \cs{rcsidlong} macro. Otherwise the macros hold
% either zero values or the values of the last file dependent on whether an
% option is enabled which enabled the \pkg{fink} package. Please see
% section~\ref{sec:date} how to typeset parts of the date. See \cs{rcskw} below
% for all other keywords.
%
% \DescribeMacro{rcsmainfilename}{}
% The macro \cs{rcsmainfilename} hold the filename of the main \LaTeX{file}. 
% It can be used to typeset this information anywhere in the document which 
% might be more descriptive as the name of the current file (which can be 
% typeset with \cs{rcskw}|{HeadURL}| or \cs{rcskw}|{Filename}| after \cs{rcsid} 
% or \cs{rcsidlong}, respectively). ^^A TODO: Change to correct names!
%
% \DescribeMacro{rcssetmainfile}{}
% This will declare the current file as the main LaTeX file by defining the 
% above macros. It will automatically be called at the end of the preamble so 
% the user normally doesn't have to use it by him- or herself as long it isn't 
% needed in the preamble.\par Please note that this macro changes the definition 
% of \cs{rcsmainfilename} directly without going over the auxiliary file.  
% Calling it in several files will make this two macros inconsistent.
%
% \DescribeMacro{rcskw}{\marg{keyword name}}
% All keywords saved with \cs{rcsid} or \cs{rcskwsave} can be typeset by this 
% macro which is a holdover from a very early version of this 
% package when multiple files where not supported.  It takes one argument which 
% must be a subversion keyword name. It then returns the current value of this 
% keyword or nothing (|\relax|) when the keyword was not set yet.
% Examples:\\
% \indent\indent |\textsl{Revision: \rcskw{Revision}}|\\
% \indent\indent |URL: \url{\rcskw{HeadURL}}|\\ ^^A TODO: Change name!
% In the second example |\url| (\pkg{hyperref} package) is used to add a hyperlink
% and to avoid problems with underscores (|_|) inside the URL.  \rcsmulti is
% also providing a macro \cs{rcsnolinkurl} which works like |\url| but doesn't
% adds an hyperlink. See the description of this macro for more details.
%
% If the given keyword doesn't exists a package warning is given to allow
% spelling errors to be tracked down. This doesn't work well when \cs{rcskw} is
% used inside |\url|. In this case the warning code will be typeset(!) verbatim
% into the document by |\url|.
%
% \DescribeMacro{rcskwdef}{\marg{keyword name}\marg{value}}
% This macro is used to define the keyword values. This is normally only called
% internally but could be used by the user to override single keywords.  The
% values can then be typeset by \cs{rcskw}.  Note that this macro has no
% influence on the calculation of the latest revision.
%
% \subsection{Accessing Date Values}\label{sec:date}
% \begin{tabular}{@{}l@{\hspace{-2\macrosep}}l@{\hspace{-2\macrosep}}l@{}}\\
% \DescribeMacro*{rcsyear}{}&
% \DescribeMacro*{rcsfileyear}{}&
% \DescribeMacro*{rcsmonth}{}&
% \DescribeMacro*{rcsfilemonth}{}&
% \DescribeMacro*{rcsday}{}&
% \DescribeMacro*{rcsfileday}{}&
% \DescribeMacro*{rcshour}{}&
% \DescribeMacro*{rcsfilehour}{}&
% \DescribeMacro*{rcsminute}{}&
% \DescribeMacro*{rcsfileminute}{}&
% \DescribeMacro*{rcssecond}{}&
% \DescribeMacro*{rcsfilesecond}{}&
% \end{tabular}
% \\*[\medskipamount]
% Whenever the date information is read, \ie by 
% \cs{rcskwsave}|{Date}| or \cs{rcsid}, the following macros are set to the 
% appropriate date parts for the 
% current file (the |\rcsfile...| versions) and for the whole document.
%
%
% \DescribeMacro{rcstime}{}
% \DescribeMacro*{rcsfiletime}{}
% This macros return the time part of the date only and simply return the
% corresponding hour, minute and second macros with a colon as separator.
%
% \DescribeMacro{rcspdfdate}{}
% Returns the last changed date of the whole document in a format needed for
% |\pdfinfo|. Can be used like this:\\
% \hbox{}\hfill|\pdfinfo{ /CreationDate (D:\rcspdfdate) }|\hfill\hbox{}\\
% to set the PDF creation date to the last changed date if you use |pdflatex| to
% compile your \LaTeX{} document.
%
% \DescribeMacro{rcstoday}{}
% \DescribeMacro*{rcsfiletoday}{}
% These macros typeset the document-global or current-file, respectively, using 
% the format of |\today| which depends on the used language.
% To adjust the language of your document use the \pkg{babel} package.
%
% \subsection{Using Full Author Names}
% If you like to have the full author\footnote{This means subversion authors,
% \eg the persons who commit changes into the rcs repository.} names, not only
% the usernames, in your document you can use the following macros. First you
% have to register all authors of the document with \cs{rcsRegisterAuthor} and
% then you can write \eg |\rcsFullAuthor{\rcsauthor}| or
% |\rcsFullAuthor{\rcsfileauthor}|.
%
% \DescribeMacro{rcsRegisterAuthor}{\marg{author}\marg{full name}}
% This macro registers \meta{full name} as full name for \meta{author} (a
% subversion username) for later use with \cs{rcsFullAuthor}.
%
% \DescribeMacro{rcsFullAuthor}{\marg{author name or macro}}
% \DescribeMacro*{rcsFullAuthor*}{\marg{author name or macro}}
% Takes the username as argument and returns the full name if it was registered
% first with \cs{rcsRegisterAuthor}, otherwise it returns the given username.
% The star version returns the username in parentheses after the full name.
% This is normally used in one of the following forms:\\
% \hspace*{3em}\cs{rcsFullAuthor}|{|\cs{rcsauthor}|}|\\
% \hspace*{3em}\cs{rcsFullAuthor}|{|\cs{rcsfileauthor}|}|\\
%
% \subsection{Using Full Revision Names}
% Like the author's also revision names/tags can be registered and used later.
% These macros were implemented on user request and have the drawback that you
% have to guess the next revision number of your document in order to get
% correct results when you like to tag the to-be-checked-in revision.  Please
% note that this has nothing to do with the normal tagging.
%
% \DescribeMacro{rcsRegisterRevision}{\marg{revision number}\marg{tag name}}
% This registers \meta{tag name} as tag name for \meta{revision number} for
% later use with \cs{rcsFullRevision}.
%
% \DescribeMacro{rcsFullRevision}{\marg{revision number or macro}}
% \DescribeMacro*{rcsFullRevision*}{\marg{revision number or macro}}
% Takes a revision number coming from a macro like \cs{rcsrev}, \cs{rcsfilerev}
% or a number as argument and returns the full name if it was registered first
% with \cs{rcsRegisterRevision}, otherwise it returns ``Revision \meta{revision
% number}''.  The star version returns also the revision number leaded by `r' in
% parentheses after the tag name, \eg |Name (1.2)|.
%
% \subsection{Verbatim URLs with and without Hyperlinks}
% \vspace{-\baselineskip}
% \DescribeMacro{rcsnolinkurl}{\marg{macro with returns special text}}
% This macro allows you to write |\rcsnolinkurl{\rcskw{HeadURL}}| and get the
% Head URL typeset verbatim. However |\url{|\cs{rcskw}|{HeadURL}}|
% (\pkg{hyperref} package) gives you the same result with a hyperlink. Both
% macros require the \pkg{hyperref} package which is not automatically loaded by
% \rcsmulti.  Please load it manually when you like to use \cs{rcsnolinkurl}.
%
% Please note that you can't use \pkg{hyperref}'s |\nolinkurl| because it won't
% expand \cs{rcskw}.
%
% \StopEventually{}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Implementation}
% \subsection{Package Header}
% \subsubsection*{Package Identification}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[1999/12/01]
\ProvidesPackage{rcs-multi}
 [\filedate\space\fileversion\space SVN Keywords for multi-file LaTeX documents]
%    \end{macrocode}

% \subsubsection*{Options}
% Declaration of options and internal switches.
%    \begin{macrocode}
\RequirePackage{kvoptions}

\SetupKeyvalOptions{%
  family = rcs-multi,
  prefix = @rcsmulti@
}
\newif\if@rcsmulti@anygraphic
\newif\if@rcsmulti@autoload

\DeclareVoidOption{old}{%
  \@rcsmulti@verbatimtrue
  \@rcsmulti@groupsfalse
  \@rcsmulti@externalfalse
  \@rcsmulti@graphicsfalse
  \@rcsmulti@pgfimagesfalse
  \@rcsmulti@autoloadfalse
  \@rcsmulti@tablefalse
  \@rcsmulti@filehooksfalse
  \@rcsmulti@subgroupsfalse
}
\DeclareVoidOption{all}{%
  \@rcsmulti@verbatimtrue
  \@rcsmulti@groupstrue
  \@rcsmulti@externaltrue
  \@rcsmulti@graphicstrue
  \@rcsmulti@pgfimagestrue
  \@rcsmulti@autoloadtrue
  \@rcsmulti@tabletrue
  \@rcsmulti@filehookstrue
  \@rcsmulti@subgroupstrue
}
\DeclareBoolOption[true]{verbatim}
\DeclareBoolOption[false]{groups}
\DeclareBoolOption[false]{external}
\DeclareBoolOption[false]{subgroups}
\DeclareBoolOption[false]{graphics}
\DeclareBoolOption[false]{pgfimages}
\DeclareStringOption{autoload}[true]
\DeclareBoolOption[false]{table}
\DeclareBoolOption[false]{filehooks}

\ExecuteOptions{old}
\ProcessKeyvalOptions{rcs-multi}
%    \end{macrocode}
%
% Enable dependent options:
%    \begin{macrocode}
\def\rcs@depoption#1{%
  \csname if@rcsmulti@#1\endcsname\else
  \message{rcs-multi: Required option '#1' enabled.}%
  \csname @rcsmulti@#1true\endcsname
  \fi
}

\if@rcsmulti@groups
  \rcs@depoption{filehooks}
\fi
\if@rcsmulti@external
  \rcs@depoption{filehooks}
\fi
\if@rcsmulti@subgroups
  \rcs@depoption{groups}
  \rcs@depoption{filehooks}
\fi
\if@rcsmulti@graphics
  \rcs@depoption{external}
  \rcs@depoption{autoload}
  \rcs@depoption{filehooks}
\fi
\if@rcsmulti@pgfimages
  \rcs@depoption{external}
  \rcs@depoption{autoload}
  \rcs@depoption{filehooks}
\fi
\if@rcsmulti@autoload
  \rcs@depoption{external}
  \rcs@depoption{filehooks}
\fi
\if@rcsmulti@table
  \rcs@depoption{groups}
  \rcs@depoption{filehooks}
\fi
%    \end{macrocode}
%
% Check if \op{autoload} was set explicitly and obey the value.
%    \begin{macrocode}
\ifx\@rcsmulti@autoload\@undefined
\else
\ifx\@rcsmulti@autoload\empty
\else
\def\rcs@temp{true}
\ifx\@rcsmulti@autoload\rcs@temp
  \@rcsmulti@autoloadtrue
  \rcs@depoption{external}
  \rcs@depoption{filehooks}
\else
\def\rcs@temp{false}
\ifx\@rcsmulti@autoload\rcs@temp
  \if@rcsmulti@autoload
  \PackageWarning{rcs-multi}{Option 'autoload' disabled.}
  \fi
  \@rcsmulti@autoloadfalse
\else
  \PackageError{rcs-multi}%
    {Invalid value for 'autoload' option: '\@rcsmulti@autoload'^^J%
     ! Only 'true','false' or empty (='true') are allowed!}
\fi\fi\fi\fi
%    \end{macrocode}

% General switch if any graphic option is enabled:
%    \begin{macrocode}
\if@rcsmulti@graphics
  \@rcsmulti@anygraphictrue
\fi
\if@rcsmulti@pgfimages
  \@rcsmulti@anygraphictrue
\fi
%    \end{macrocode}
%

% \subsection{General Internal Macros}
% Some internal used macro which don't fit in any other section.
%
% \begin{macro}{\rcs@ifempty}[1]{string}
% Tests if the given argument is empty. If so the first of the next two token
% will be expanded, the second one otherwise.
%    \begin{macrocode}
\def\rcs@ifempty#1{%
  \begingroup
  \edef\rcs@temp{#1}%
  \ifx\rcs@temp\empty
    \endgroup
    \expandafter
    \@firstoftwo
  \else
    \endgroup
    \expandafter
    \@secondoftwo
  \fi
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@ifequal}[2]{string a}{string b}
% Tests if the given arguments are identical, \eg same strings. If so the first
% of the next two token will be expanded, the second one otherwise.
%    \begin{macrocode}
\def\rcs@ifequal#1#2{%
  \begingroup
  \edef\rcs@stringa{#1}%
  \edef\rcs@stringb{#2}%
  \ifx\rcs@stringa\rcs@stringb
    \endgroup
    \expandafter
    \@firstoftwo
  \else
    \endgroup
    \expandafter
    \@secondoftwo
  \fi
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@ifvalidrev}[1]{macro name}
% Checks if the given macro (by name) is a valid revision, \ie defined and
% greater than zero.
%    \begin{macrocode}
\def\rcs@ifvalidrev#1{%
  \begingroup
  \@ifundefined{#1}%
    {\def\rcs@temp{-1}}%
    {\expandafter\edef
     \expandafter\rcs@temp\expandafter{\csname #1\endcsname}}%
  \ifnum\rcs@temp>-1\relax
    \endgroup
    \expandafter
    \@firstoftwo
  \else
    \endgroup
    \expandafter
    \@secondoftwo
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rcs@input}[1]{file name/path}
% Macro to load |.svx| and |.svt| files.  The current keyword group is saved
% away and restored after the |.svx| file is loaded.  The macros |\IfFileExists|
% with |\@@input| are used because |\InputIfFileExists| got redefined by the
% \pkg{fink} package and there is no need to use \pkg{fink} for this files.
%    \begin{macrocode}
\def\rcs@input#1{%
  \begingroup
    \let\rcs@rg\rcs@g
    \IfFileExists{#1}{\@@input #1\relax}{}%
    \global\let\rcs@g\rcs@rg
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rcs@inputsvx}[1]{file name/path without extension}
% Used to save and restore file keywords when reading |.svx| files.
%    \begin{macrocode}
\def\rcs@inputsvx#1{%
  \rcs@pushfilestack
  \rcs@input{#1.svx}%
  \rcs@popfilestack
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@namexdef}[1]{macro name}
% Provides an expanding and global version of |\@namedef|.
%    \begin{macrocode}
\providecommand\@namexdef[1]{%
  \expandafter\xdef\csname #1\endcsname
}
%    \end{macrocode}
% \end{macro}
%

% \subsection{Definition of init values}
% Initialisation of at least the revision to a numeric value is necessary to not
% break the |\ifnum| tests later in this package. The revision is initialised to
% -1, but will be set to 0 if an unexpanded |$||Rev:$| keyword is read. This way
% it can be tested if a file had any keyword macros or not.\par
% Note that there a two different macros for the document global keywords:\par
% The user level |\rcs|\meta{kw} macros hold the global value and are only valid
% after a \LaTeX\ run. They are initialised here and defined in the |.rcs|
% file which is read at the end of the package if it exists and written at the
% end of the document.\par
% The internal macros |\@rcs@|\meta{kw} store the oldest (i.e. highest revision)
% keywords read so far from the \cs{rcsid} and \cs{rcsidlong} macros. They
% change during the document and are used to produce the values of the
% |\rcs|\meta{kw} macros when the |.rcs| file is written.\par
% Group wide macros are initialised when the group is first defined and have
% three different macros: |\rcsg@|\meta{group}|@|\meta{kw} (defined in |.rcs|),
% |\@rcsg@|\meta{group}|@|\meta{kw} (accumulator) and also an access
% macro |\rcscg|\meta{group} which uses
% |\rcs@g|\meta{current group}|@|\meta{kw}.
%    \begin{macrocode}
% Init values
\def\rcsrev{-1}             \def\@rcs@rev{-1}
\def\rcsdate{}              \def\@rcs@date{}
\def\rcsauthor{}            \def\@rcs@author{}
\def\rcsyear{0000}          \def\@rcs@year{0000}
\def\rcsmonth{00}           \def\@rcs@month{00}
\def\rcsday{00}             \def\@rcs@day{00}
\def\rcshour{00}            \def\@rcs@hour{00}
\def\rcsminute{00}          \def\@rcs@minute{00}
\def\rcssecond{00}          \def\@rcs@second{00}
\def\rcstimezonehour{+00}   \def\@rcs@timezonehour{+00}
\def\rcstimezoneminute{00}  \def\@rcs@timezoneminute{00}
\def\rcsmainurl{NOT SET}    \def\rcsmainfilename{NOT SET}
\def\rcsurl{} \def\rcsfname{}
\def\rcs@temp{}

\def\rcs@pg{} \def\rcs@g{} \def\rcs@cg{\rcs@g}
\let\@rcsg@@files\relax

\def\rcs@initfile{%
  \gdef\rcsfilerev{-1}%
  \gdef\rcsfiledate{}%
  \gdef\rcsfileauthor{}%
  \gdef\rcsfileyear{0000}%
  \gdef\rcsfilemonth{00}%
  \gdef\rcsfileday{00}%
  \gdef\rcsfilehour{00}%
  \gdef\rcsfileminute{00}%
  \gdef\rcsfilesecond{00}%
  \gdef\rcsfiletimezonehour{+00}%
  \gdef\rcsfiletimezoneminute{00}%
  \gdef\rcsfileurl{}%
  \gdef\rcsfilefname{}%
}
\rcs@initfile
%    \end{macrocode}
%
% \subsection{Timezone macros}
% \begin{macro}{\rcstimezone}
% \begin{macro}{\rcsfiletimezone}
% \begin{macro}{\rcscgtimezone}
% These macros return the global, file-local and current group time zones,
% respectively. Since v1.4 the minute part is returned as well and the macro
% removes manually added |00| after it to support older documents.
% \changes{v1.4}{2009/02/27}{Return now full timezone (hour + minute part).
% Manually added 00 minutes are removed.}
%    \begin{macrocode}
\def\rcstimezone{\rcstimezonehour\rcstimezoneminute\rcs@gobblezeros}
\def\rcsfiletimezone{\rcsfiletimezonehour\rcsfiletimezoneminute\rcs@gobblezeros}
\def\rcscgtimezone{\rcscgtimezonehour\rcscgtimezoneminute}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}

% \begin{macro}{\rcs@gobblezeros}
% \begin{macro}{\rcs@gobblezeros@}
% This two cascaded macros remove a trailing |00| and are used by
% \cs{rcsfiletimezone} and \cs{rcstimezone}.
%    \begin{macrocode}
\def\rcs@gobblezeros{%
  \futurelet\rcs@nextchar\rcs@gobblezeros@
}
\def\rcs@gobblezeros@{%
  \let\@tempa=\relax
  \def\@tempb{0}%
  \ifx0\rcs@nextchar
    \let\@tempa=\@gobbletwo
  \fi
  \@tempa
}
%    \end{macrocode}
% \end{macro}
% \end{macro}

% \begin{macro}{\rcstime}
% \begin{macro}{\rcsfiletime}
% \begin{macro}{\rcscgtime}
% This macros simple use the hour, minute and second macros.
%    \begin{macrocode}
\def\rcstime{\rcshour:\rcsminute:\rcssecond}
\def\rcsfiletime{\rcsfilehour:\rcsfileminute:\rcsfilesecond}
\def\rcscgtime{\rcscghour:\rcscgminute:\rcscgsecond}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}

% \subsection{\textit{Today} macros}
% These macros use the |\today| macro to typeset the current date using the
% local language settings. Thanks and credit goes to Manuel P\'egouri\'e-Gonnard
% for suggesting this feature and for providing the code.
% \begin{macro}{\rcstoday}
%    \begin{macrocode}
\newcommand*{\rcstoday}{%
  \begingroup
    \year\rcsyear \month\rcsmonth \day\rcsday
    \relax \today
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rcsfiletoday}
%    \begin{macrocode}
\newcommand*{\rcsfiletoday}{%
  \begingroup
    \year\rcsfileyear \month\rcsfilemonth \day\rcsfileday
    \relax \today
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rcscgtoday}
%    \begin{macrocode}
\newcommand*{\rcscgtoday}{%
  \@ifundefined{rcsg@\rcs@cg @year}{??}{%
    \begingroup
      \year\rcscgyear \month\rcscgmonth \day\rcscgday
      \relax \today
    \endgroup
  }%
}%
%    \end{macrocode}
% \end{macro}

% \subsection{Id macros}
% \subsubsection{Normal Id}
% \begin{macro}{\rcsid}
% Calls \cs{rcskwsave} with |\@rcsidswtrue| so that the Id keyword will be
% parsed at the end of \cs{rcskwsave}.
%    \begin{macrocode}
\newcommand*{\rcsid}{%
  \@rcsidswtrue
  \rcskwsave
}
\newif\if@rcsidsw
\@rcsidswfalse
%    \end{macrocode}
% \end{macro}
%

% \begin{macro}{\rcs@scanId}[5]{file name}{revision}{date (YYYY-MM-DD)}{time
% (HH:MM:SSZ)}{author (username)}
% Scans rcs Id (after it got parsed by \cs{rcskwsave}).  Awaits only Id value
% without leading `|Id:|' and a trailing |\relax| as end marker.  It calls
% \cs{@rcs@scandate} to extract the date information and \cs{@rcs@updateid} to
% update global Id values and also sets the appropriate keywords.
%    \begin{macrocode}
\def\rcs@scanId#1 #2 #3 #4 #5\relax{%
  \@rcs@scandate{#3 #4}%
  \@rcs@updateid{#2}{#3 #4}{#5}{#1}%
  \rcskwdef{Filename}{#1}%
  \rcskwdef{Date}{#3 #4}%
  \rcskwdef{Revision}{#2}%
  \rcskwdef{Author}{#5}%
}
%    \end{macrocode}
% \end{macro}
%

% \begin{macro}{\@rcs@updateid}[4]{rev}{date}{author (username)}{url}
% We first define the expanded arguments to variables for the user.  The
% expansion is needed because the arguments content is mostly generic like
% |\rcs@value| which can change very soon after this macro.
%    \begin{macrocode}
\def\@rcs@updateid#1#2#3#4{%
  \xdef\rcsfilerev{#1}%
  \xdef\rcsfiledate{#2}%
  \xdef\rcsfileauthor{#3}%
  \xdef\rcsfileurl{#4}%
  \rcs@getfilename\rcsfileurl%
%    \end{macrocode}
% Then we check if the revision is non-empty (not yet expanded by subversion?)
% and larger then the current maximum value |\@rcs@rev|.  If yes we save all
% value to save them in the .rcs-file later.
%    \begin{macrocode}
  \ifx\rcsfilerev\empty\else
    \ifnum\@rcs@rev<\rcsfilerev
      \xdef\@rcs@rev{\rcsfilerev}%
      \xdef\@rcs@date{\rcsfiledate}%
      \xdef\@rcs@author{\rcsfileauthor}%
      \xdef\@rcs@year{\rcsfileyear}%
      \xdef\@rcs@month{\rcsfilemonth}%
      \xdef\@rcs@day{\rcsfileday}%
      \xdef\@rcs@hour{\rcsfilehour}%
      \xdef\@rcs@minute{\rcsfileminute}%
      \xdef\@rcs@second{\rcsfilesecond}%
      \xdef\@rcs@timezonehour{\rcsfiletimezonehour}%
      \xdef\@rcs@timezoneminute{\rcsfiletimezoneminute}%
      \xdef\@rcs@url{\rcsfileurl}%
      \xdef\@rcs@fname{\rcsfilefname}%
    \fi

    \if@rcsmulti@groups
      \ifx\rcs@g\empty\else
        \rcs@updategroup{\rcs@g}%
      \fi
      \if@rcsmulti@subgroups
        \ifrcssubgroups
          \rcs@updategroup{\rcs@filedir\rcs@filebase}%
        \fi
      \fi
    \fi
  \fi
}

\def\@rcscg@save#1#2{%
  \expandafter\xdef\csname @rcsg@\rcs@g @#1\endcsname{#2}%
}

%    \end{macrocode}
% \end{macro}
%

% \subsubsection{Long Id}
% \begin{macro}{\rcsidlong}
% We clear the keyword value first to reduce the risk though bad user input.
%    \begin{macrocode}
\newcommand{\rcsidlong}{%
  \rcskwdef{HeadURL}{}%
  \rcskwdef{LastChangedDate}{}%
  \rcskwdef{LastChangedRevision}{0}%
  \rcskwdef{LastChangedBy}{}%
%    \end{macrocode}
% The catcodes are changed by \cs{rcs@catcodes} to allow \TeX-special characters
% inside the keywords.  The braces |{ }| are changed to allow comments between
% the arguments.  \cs{rcsidlong@readargsfull} is called to read the arguments.
%    \begin{macrocode}
  \begingroup
    \if@rcsmulti@verbatim
      \rcs@catcodes
      \catcode`\{=12
      \catcode`\}=12
    \else
      \def\rcsidlong@readargsfull{\rcsidlong@readargs}%
    \fi
    \rcsidlong@readargsfull
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@catcodes}
% Changes all \TeX-special character to category ``other''. The newline aka
% return is changed to category ``ignore'' so line breaks are not taken as part
% of the verbatim arguments.
%    \begin{macrocode}
\if@rcsmulti@verbatim
\def\rcs@catcodes{%
  \let\do\@makeother
  \dospecials
  \catcode`\^^M9
  \catcode`\ 10
  \catcode`\{1
  \catcode`\}2
}
\else
  \def\rcs@catcodes{}
\fi
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsidlong@readargsfull}[8]
% {some text, ignored}{Keyword 1}
% {some text, ignored}{Keyword 2}
% {some text, ignored}{Keyword 3}
% {some text, ignored}{Keyword 4}
% Reads all four arguments of \cs{rcsidlong} and passes them to
% \cs{rcsidlong@readargs}. The normal argument braces are changed to category
% ``other'' and put into the macros parameter text to remove all code between
% them. This is done to avoid problems with comments direct after one of the
% arguments. Because the braces are now non-special the parentheses are made to
% a local replacement.
%
%    \begin{macrocode}
\if@rcsmulti@verbatim
\begingroup
\catcode`\{=12\catcode`\}=12
\catcode`\(=1\catcode`\)=2
\gdef\rcsidlong@readargsfull#1{#2}#3{#4}#5{#6}#7{#8}(%
 \rcsidlong@readargs(#2)(#4)(#6)(#8)%
)
\endgroup
\fi
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsidlong@readargs}[4]{Keyword 1}{Keyword 2}{Keyword 3}
% {Keyword 4}
% Calls sub macro for all four arguments and ends the catcode changes made
% by \cs{rcsidlong}.
%    \begin{macrocode}
\def\rcsidlong@readargs#1#2#3#4{%
    \rcskwsave@read #1\relax
    \rcskwsave@read #2\relax
    \rcskwsave@read #3\relax
    \rcskwsave@read #4\relax
  \endgroup
%    \end{macrocode}
% Now the update macros for date and id are called.
%    \begin{macrocode}
  \ifx\rcskwLastChangedDate\empty\else
    \@rcs@scanlongdate{\rcskwLastChangedDate}%
  \fi
  \@rcs@updateid{\rcskw{LastChangedRevision}}{\rcskw{LastChangedDate}}%
  {\rcskw{LastChangedBy}}{\rcskw{HeadURL}}%
  \ignorespaces
}%
%    \end{macrocode}
% \end{macro}

% \subsection{KeyWord Macros}
% \begin{macro}{\rcskwsave}
% Enabled verbatim mode and uses a sub macro to read the arguments afterwards.
%    \begin{macrocode}
\def\rcskwsave{%
  \begingroup
    \rcs@catcodes
    \rcskwsave@readargs
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcskwsave@readargs}[1]{\$kw: value\$}
% Reads full argument, calls parse submacro and ends catcode changes.
% If \cs{rcskwsave} was called by \cs{rcsid} scans the id keyword by calling the
% scan macro.
%    \begin{macrocode}
\gdef\rcskwsave@readargs#1{%
    \rcskwsave@read#1\relax
  \endgroup
  \if@rcsidsw
    \ifx\rcskwId\empty\else
      \expandafter
      \rcs@scanId\rcskwId\relax
      \@rcsidswfalse
    \fi
  \fi
  \ignorespaces
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcskwsave@read}[1]{keyword line without surrounding \$ \$}
% Reads the full keyword and strips the dollars.
%    \begin{macrocode}
\begingroup
\if@rcsmulti@verbatim
\catcode`\$=12
\fi
\gdef\rcskwsave@read $#1$\relax{%
  \rcs@checkcolon#1:\relax
}
\endgroup
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcskwsave@parse}[2]{key}{value}
% Parse the keyword and save it away.
%    \begin{macrocode}
\begingroup
\catcode`\$=11
\gdef\rcskwsave@parse$#1:#2${%
  \expandafter\xdef\csname rcskw#1\endcsname{#2}%
}%
\endgroup
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcskwdef}[2]{key}{value}
% First we check if there is a `setter'-macro for the keyword called
% \cs{rcskwdef@}\meta{keyword}.
%    \begin{macrocode}
\newcommand{\rcskwdef}[2]{%
  \@ifundefined{rcskwdef@#1}%
%    \end{macrocode}
% If not we call the general macro \cs{rcskwdef@}.
%    \begin{macrocode}
    {\rcskwdef@{#1}{#2}}%
%    \end{macrocode}
% If yes we just call it with the value as argument.
%    \begin{macrocode}
    {\csname rcskwdef@#1\endcsname{#2}}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcskwdef@}[2]{key}{value}
% This macro defines the second argument under \cs{rcskw}\meta{1st argument}.
% The |\xdef| is used to expand the content first (needed for internal use) and
% make the definition globally.
%    \begin{macrocode}
\newcommand{\rcskwdef@}[2]{%
  \expandafter\xdef\csname rcskw#1\endcsname{#2}%
}
%    \end{macrocode}
% Example: |\rcskwdef{Revision}{23}| will define |\rcskwRevision| as 23.
% \end{macro}

% \begin{macro}{\rcskwdef@Rev}
% \begin{macro}{\rcskwdef@Author}
% \begin{macro}{\rcskwdef@Date}
% \begin{macro}{\rcskwdef@URL}[1]{value}
% `Setter'-macros for single keywords, used by \cs{rcskwdef}.\\ These are needed
% to have have a common value for all alternative keyword names ala |Rev|,
% |Revision|, |LastChangedRevision|.
%
% The keywords |Author| and |Date| are just calling \cs{rcskwdef@} with a fixed
% first argument.  For the revision the value is checked if empty and then a 0
% is substituted.
%    \begin{macrocode}
\def\rcskwdef@Rev#1{%
  \rcs@ifempty{#1}%
    {\rcskwdef@{Rev}{0}}%
    {\rcskwdef@{Rev}{#1}}%
}
\def\rcskwdef@Author#1{\rcskwdef@{Author}{#1}}
\def\rcskwdef@Date#1{\rcskwdef@{Date}{#1}}
\def\rcskwdef@URL#1{\rcskwdef@{HeadURL}{#1}}
%    \end{macrocode}
% The long keywords are defined then as aliases of the short,\\
% first for writing
%    \begin{macrocode}
\let\rcskwdef@Revision=\rcskwdef@Rev
\let\rcskwdef@LastChangedRevision=\rcskwdef@Rev
\let\rcskwdef@LastChangedBy=\rcskwdef@Author
\let\rcskwdef@LastChangedAt=\rcskwdef@Date
%    \end{macrocode}
% and then for reading.
%    \begin{macrocode}
\def\rcskwRevision{\rcskwRev}
\def\rcskwLastChangedRevision{\rcskwRev}
\def\rcskwLastChangedBy{\rcskwAuthor}
\def\rcskwLastChangedAt{\rcskwDate}
\def\rcskwURL{\rcskwHeadURL}
%    \end{macrocode}
% So \eg |\rcskw{LastChangedRevision}| is always be the
% same as |\rcskw{Rev}|.
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

% We define default values for normal keywords. Keyword |Filename| is the name
% given by |Id| and not a real keyword.
%    \begin{macrocode}
\rcskwdef{Rev}{0}
\rcskwdef{Date}{}
\rcskwdef{Author}{}
\rcskwdef{Filename}{}
\rcskwdef{HeadURL}{}
%    \end{macrocode}

% \begin{macro}{\rcskw}[1]{keyword name}
% Macro to get keyword value. Just calls \cs{rcskw}\meta{ARGUMENT} where
% the argument interpreted as text. So \eg |\rcskw{Date}| is the same as
% |rcskwDate| but this could be changed later so always use this interface
% to get the keyword values.
%
% \changes{v1.2}{2007/06/22}{Added warning when a wrong, maybe
% misspelled, keyword is given.}
%    \begin{macrocode}
\newcommand{\rcskw}[1]{%
  \@ifundefined{rcskw#1}%
    {\PackageWarning{rcs-multi}{SVN keyword '#1' not defined (typo?)}}%
    {\csname rcskw#1\endcsname}%
}%
%    \end{macrocode}
% \end{macro}
%

% \subsection{Keyword check and strip macros}
% The following macros are used to test whether the given keywords are fully
% expanded or not.
% RCS supports unexpanded keywords as input with or without colon and
% with or without trailing space(s), \ie a:~|$KW$|, b:~|$KW:$| or c:~|$KW: $|.
% To avoid \LaTeX{} syntax errors in this pre-commit state the keyword is
% checked by the following macros. Unexpanded keywords result in an empty value.
% Also leading and trailing spaces are removed.
%
% \begin{macro}{\rcs@checkcolon}[2]{key}{potential value, might be empty}
% Checks if the keyword contains a colon. It is called by \cs{rcskwsave@read}
% with a trailing |:\relax| so that \#2 will be empty if there is no earlier
% colon or will hold the value with this trailing colon otherwise.
% The first case means that the keyword is unexpanded without colon (case a)
% which leads to an empty value. In the second case \cs{rcs@stripcolon} is
% called to strip the colon and surrounding spaces. The final value is
% returned by |\rcs@value|.
%    \begin{macrocode}
\def\rcs@checkcolon#1:#2\relax{%
  \rcs@ifempty{#2}%
    {\rcskwdef{#1}{}}%
    {\rcs@stripcolon#2\relax\rcskwdef{#1}{\rcs@value}}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@stripcolon}[1]{potential value}
% Strips the previous added colon (for \cs{rcs@checkcolon}).
% The remaining argument is checked if it's empty (case b) or only a space
% (case c). Otherwise the keyword is expanded and \cs{rcs@stripspace} is
% called to strip the spaces.
%    \begin{macrocode}
\def\rcs@stripcolon#1:\relax{%
  \rcs@ifempty{#1}%
    {\gdef\rcs@value{}}%
    {\rcs@ifequal{#1}{ }%
      {\gdef\rcs@value{}}%
      {\rcs@stripspace#1\relax\relax}%
    }%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@stripspace}[2]{first character}{rest of string}
% Strips leading space if present and calls \cs{rcs@striptrailingspace} to
% strip the trailing space.
%    \begin{macrocode}
\def\rcs@stripspace#1#2\relax{%
  \rcs@ifequal{#1}{ }%
    {\gdef\rcs@value{#2}}%
    {\rcs@striptrailingspace#1#2\relax}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@striptrailingspace}[1]{string}
% Strips trailing space using the macros parameter text. Must be called with
% |\relax| as end marker.
%    \begin{macrocode}
\def\rcs@striptrailingspace#1 \relax{%
  \gdef\rcs@value{#1}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@gdefverb}[1]{macro}
%    \begin{macrocode}
\def\rcs@gdefverb#1{%
  \begingroup
    \def\rcs@temp{#1}%
    \begingroup
      \if@rcsmulti@verbatim
        \rcs@catcodes
      \fi
      \rcs@gdefverb@
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@defverb@}[1]{verbatim stuff}
%    \begin{macrocode}
\def\rcs@gdefverb@#1{%
    \endgroup
    \expandafter\gdef\rcs@temp{#1}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@namegdefverb}[1]{macro name}
%    \begin{macrocode}
\def\rcs@namegdefverb#1{%
  \begingroup
    \expandafter\def
    \expandafter\rcs@temp
    \expandafter{\csname #1\endcsname}%
    \begingroup
      \if@rcsmulti@verbatim
        \rcs@catcodes
      \fi
      \rcs@gdefverb@
}
%    \end{macrocode}
% \end{macro}


% \subsection{Date Macros}
% \begin{macro}{\@rcs@scandate}[1]{date}
% Scans data information in Id keyword and saves them in macros.
%    \begin{macrocode}
\def\@rcs@scandate#1{\@rcs@scandate@#1\relax}

\def\@rcs@scandate@#1-#2-#3 #4:#5:#6#7#8\relax{%
  \gdef\rcsfileyear{#1}%
  \gdef\rcsfilemonth{#2}%
  \gdef\rcsfileday{#3}%
  \gdef\rcsfilehour{#4}%
  \gdef\rcsfileminute{#5}%
  \gdef\rcsfilesecond{#6#7}%
  \gdef\rcsfiletimezonehour{+00}%
  \gdef\rcsfiletimezoneminute{00}% #8 always 'Z' for Zulu-time (UTC)
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\@rcs@scanlongdate}[8]{Year}{Month}{Day}{Hour}{Minute}{Second}
% {Timezone}{Date description string (ignored)}
% Scans date information in Date keyword and saves them in macros.
%    \begin{macrocode}
\def\@rcs@scanlongdate#1{\expandafter\@rcs@scanlongdate@#1\relax}
%
\def\@rcs@scanlongdate@#1-#2-#3 #4:#5:#6 #7 #8\relax{%
  \gdef\rcsfileyear{#1}%
  \gdef\rcsfilemonth{#2}%
  \gdef\rcsfileday{#3}%
  \gdef\rcsfilehour{#4}%
  \gdef\rcsfileminute{#5}%
  \gdef\rcsfilesecond{#6}%
  \@rcs@parsetimezone#7\relax%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\@rcs@parsetimezone}[5]{sign (+/-)}{hour first digit}{hour
% second digit}{minute first digit}{minute second digit}
% Scans timezone and splits hour and minute part.
%    \begin{macrocode}
\def\@rcs@parsetimezone#1#2#3#4#5\relax{%
  \gdef\rcsfiletimezonehour{#1#2#3}%
  \gdef\rcsfiletimezoneminute{#4#5}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcspdfdate}
% Returns date in a format needed for |\pdfinfo|.
%    \begin{macrocode}
\def\rcspdfdate{%
  \rcsyear\rcsmonth\rcsday
  \rcshour\rcsminute\rcssecond\rcstimezonehour'\rcstimezoneminute'%
}
%    \end{macrocode}
% \end{macro}

% \subsection{Mainfile Makros}
% \begin{macro}{\rcssetmainfile}
% Saves the current |HeadURL| and |Filename| keywords to macros.
% Will be called automatically in the preamble.
% \changes{v1.2}{2007/06/22}{New macro}
%    \begin{macrocode}
\newcommand{\rcssetmainfile}{%
  \xdef\rcsmainurl{\rcsfileurl}%
  \xdef\rcsmainfilename{\rcsfilefname}%
}
\AtBeginDocument{\rcssetmainfile}
%    \end{macrocode}
% \end{macro}

% \subsection{Register and FullName Macros}
% \begin{macro}{\rcsRegisterAuthor}[2]{author username}{Full Name}
% Saves the author's name by defining |rcs@author@|\meta{username} to it.
%    \begin{macrocode}
\newcommand{\rcsRegisterAuthor}[2]{%
  \expandafter\def\csname rcs@author@#1\endcsname{#2}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsFullAuthor}
% \begin{macro}{\rcsFullAuthor*}
% We test if the starred or the normal version is used and call the
% appropriate submacro |rcsFullAuthor@star| or |rcsFullAuthor@normal|.
% \changes{v1.2}{2007/06/22}{Macro now returns the username if the full name
% was not registered.}
%    \begin{macrocode}
\newcommand{\rcsFullAuthor}{%
  \@ifnextchar{*}%
    {\rcsFullAuthor@star}%
    {\rcsFullAuthor@normal}%
}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\rcsFullAuthor@star}[1]{username}
% Both submacros are calling |rcsFullAuthor@| but with different arguments.
% The star macro also removes the star of course.
%    \begin{macrocode}
\def\rcsFullAuthor@star*#1{%
  \edef\rcs@temp{#1}%
  \rcsFullAuthor@{\rcs@temp}{~(\rcs@temp)}%
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcsFullAuthor@normal}[1]{username}
%    \begin{macrocode}
\def\rcsFullAuthor@normal#1{%
  \edef\rcs@temp{#1}%
  \rcsFullAuthor@{\rcs@temp}{}%
}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcsFullAuthor@}[2]{username}{previous defined trailing string}
% |rcsFullAuthor@| now sets the author's full name. Note that |#2| is empty
% when the normal version is called.
%    \begin{macrocode}
\def\rcsFullAuthor@#1#2{%
  \@ifundefined{rcs@author@#1}%
    {#1}%
    {\csname rcs@author@#1\endcsname #2}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsRegisterRevision}[2]{revision number}{tag name}
% Saves the revision's name or tag by defining
% |rcs@revision@|\meta{revisionnumber} to it.
% \changes{v1.2}{2007/06/22}{New macro}
%    \begin{macrocode}
\newcommand{\rcsRegisterRevision}[2]{%
  \expandafter\def\csname rcs@revision@#1\endcsname{#2}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsFullRevision}
% \begin{macro}{\rcsFullRevision*}
% We test if the starred or the normal version is used and call the
% appropriate submacro |rcsFullRevision@star| or |rcsFullRevision@normal|.
% \changes{v1.2}{2007/06/22}{New macro}
%    \begin{macrocode}
\newcommand{\rcsFullRevision}{%
  \@ifnextchar{*}%
    {\rcsFullRevision@star}%
    {\rcsFullRevision@normal}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\rcsFullRevision@star}[1]{revision number}
% Both submacros are calling |rcsFullRevision@| but with different arguments.
% The star macro also removes the star of course.
%    \begin{macrocode}
\def\rcsFullRevision@star*#1{%
  \edef\rcs@temp{#1}%
  \rcsFullRevision@{\rcs@temp}{~(r\rcs@temp)}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcsFullRevision@normal}[1]{revision number}
%    \begin{macrocode}
\def\rcsFullRevision@normal#1{%
  \edef\rcs@temp{#1}%
  \rcsFullRevision@{\rcs@temp}{}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcsFullRevision@}[2]{revision number}{previous defined trailing
% string}
% |rcsFullRevision@| now sets the revision name. Note that |#2| is empty
% when the normal version is called.
%    \begin{macrocode}
\def\rcsFullRevision@#1#2{%
  \@ifundefined{rcs@revision@#1}%
    {Revision #1}%
    {\csname rcs@revision@#1\endcsname #2}%
}
%    \end{macrocode}
% \end{macro}

% \subsection{Input File Name}
% The \pkg{fink} package is used to get the input file names. AtBegin/AtEnd 
% hooks are installed which will be used later.
%    \begin{macrocode}
\if@rcsmulti@filehooks
%    \end{macrocode}

% Load \pkg{fink} package and check if all needed macros are provided.
%    \begin{macrocode}
\RequirePackage{fink}[2008/02/27]
\begingroup
\def\rcs@finkerror{%
\PackageError{rcs-multi}{Your installed version of the 'fink' package does not
provide the needed macros. It is either too old or too new.
Try a different version, e.g. v2.1.1 from 2008/02/27}{}%
\let\rcs@finkerror\relax
}
\@ifundefined{finkpath}{\rcs@finkerror}{}%
\@ifundefined{finkdir}{\rcs@finkerror}{}%
\@ifundefined{finkbase}{\rcs@finkerror}{}%
\@ifundefined{fink@prepare}{\rcs@finkerror}{}%
\@ifundefined{fink@restore}{\rcs@finkerror}{}%
\@ifundefined{fnk@maindir}{\rcs@finkerror}{}%
\@ifundefined{fnk@mainext}{\rcs@finkerror}{}%
\endgroup
%    \end{macrocode}

% \begin{macro}{\rcs@removedotslash}[1]{string (\eg file path) which might start
% with \texttt{./}}
% Removes leading './' from given macro (holding a directory path). Awaits a
% macro as argument which is redefined inside the current group!
%    \begin{macrocode}
\def\rcs@removedotslash#1{%
  \def\rcs@removedotslash@##1##2##3\relax{%
    \rcs@ifequal{./}{##1##2}%
      {\edef#1{##3}\def\next{\rcs@removedotslash@##3\empty\empty\empty\relax}}%
      {\edef#1{##1##2##3}\let\next\relax}%
    \next
  }%
  \expandafter\rcs@removedotslash@#1\empty\empty\empty\relax
}
%    \end{macrocode}
% \end{macro}

% Init values for file name macros.
%    \begin{macrocode}
\let\rcs@mainext\fnk@mainext
\let\rcs@maindir\fnk@maindir
\rcs@removedotslash\rcs@maindir
\edef\rcs@filebase{\jobname}%
\edef\rcs@fileext{\rcs@mainext}%
\edef\rcs@filedir{\rcs@maindir}%
%    \end{macrocode}
% Filename and -path are build using the other macros:
%    \begin{macrocode}
\def\rcs@filename{\fink@file\rcs@filebase\rcs@fileext}%
\def\rcs@filepath{\rcs@filedir\rcs@filename}%
%    \end{macrocode}

% \begin{macro}{\rcsmulti@begininputfilehook}
% This hook is installed in the |\fink@prepare| macro from the \pkg{fink}
% package which will be executed at the begin of a input file. The file name and
% path are not yet in |\finkpath| etc. but in |\fink@nextpath|.
%    \begin{macrocode}
\def\rcsmulti@begininputfilehook{}
\message{Package rcs-multi: patching macro '\string\fink@prepare' from the
'fink' package!}%
\let\rcsmulti@fink@prepare\fink@prepare
\renewcommand*{\fink@prepare}[1]{%
  \rcsmulti@fink@prepare{#1}%
  \if@rcsmulti@groups
    \rcs@ifequal{\rcs@filepath}{\jobname.\rcs@mainext}%
      {\global\let\rcs@pg\rcs@g}%
      {\xdef\rcs@pg{\rcs@filedir\rcs@filebase}}%
  \fi
  \xdef\rcs@filebase{\fink@nextbase}%
  \xdef\rcs@fileext{\fink@nextext}%
  \xdef\rcs@filedir{\fink@nextdir}%
  \rcs@removedotslash\rcs@filedir
  \rcsmulti@begininputfilehook
}%
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsmulti@endinputfilehook}
% This hook is installed in the |\fink@restore| macro from the \pkg{fink}
% package which will be executed at the end of a input file. The file path
% |\finkpath| etc. is still valid.
%    \begin{macrocode}
\def\rcsmulti@endinputfilehook{}
\message{Package rcs-multi: patching macro '\string\fink@restore' from the
'fink' package!}%
\let\rcsmulti@fink@restore\fink@restore
\def\fink@restore#1{%
  \rcsmulti@endinputfilehook
  \rcsmulti@fink@restore{#1}%
  \xdef\rcs@filebase{\finkbase}%
  \xdef\rcs@fileext{\finkext}%
  \xdef\rcs@filedir{\finkdir}%
  \rcs@removedotslash\rcs@filedir
}%
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsmulti@atbegininputfile}
% This macro adds the argument to the end of the \cs{rcsmulti@begininputfilehook}.
%    \begin{macrocode}
\def\rcsmulti@atbegininputfile{%
  \g@addto@macro\rcsmulti@begininputfilehook
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsmulti@atendinputfile}
% This macro adds the argument to the \emph{begin} of the
% \cs{rcsmulti@endinputfilehook}. This ensures that code added first is more at
% the end than code added later.
% The code below was adapted from the definition of the \LaTeX2e macro
% |\g@addto@macro| which was used above.
%    \begin{macrocode}
\long\def\rcsmulti@atendinputfile#1{%
  \begingroup
    \@temptokena\expandafter{\rcsmulti@endinputfilehook}%
    \toks@{#1}%
    \xdef\rcsmulti@endinputfilehook{\the\toks@\the\@temptokena}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}

%    \begin{macrocode}
\def\rcs@filestack{{}}

\def\rcs@pushfilestack{%
  \xdef\rcs@filestack{{%
    {\rcsfilerev}%
    {\rcsfiledate}%
    {\rcsfileauthor}%
    {\rcsfileyear}%
    {\rcsfilemonth}%
    {\rcsfileday}%
    {\rcsfilehour}%
    {\rcsfileminute}%
    {\rcsfilesecond}%
    {\rcsfiletimezonehour}%
    {\rcsfiletimezoneminute}%
    {\rcsfileurl}%
    {\rcsfilefname}%
    {\rcs@g}%
    {\rcs@pg}%
  }\rcs@filestack}%
}

\def\rcs@restorefilekws#1#2\relax{%
  \rcs@restorefilekws@#1\empty
  \empty \empty \empty \empty
  \empty \empty \empty \empty
  \empty \empty \empty \empty
  \rcs@ifempty{#2}%
    {\gdef\rcs@filestack{{}}}%
    {\gdef\rcs@filestack{#2}}%
}
\def\rcs@restorefilekws@#1#2#3#4#5#6#7#8#9{%
  \gdef\rcsfilerev{#1}%
  \gdef\rcsfiledate{#2}%
  \gdef\rcsfileauthor{#3}%
  \gdef\rcsfileyear{#4}%
  \gdef\rcsfilemonth{#5}%
  \gdef\rcsfileday{#6}%
  \gdef\rcsfilehour{#7}%
  \gdef\rcsfileminute{#8}%
  \gdef\rcsfilesecond{#9}%
  \rcs@restorefilekws@@
}

\def\rcs@restorefilekws@@#1#2#3#4#5#6{%
  \gdef\rcsfiletimezonehour{#1}%
  \gdef\rcsfiletimezoneminute{#2}%
  \gdef\rcsfileurl{#3}%
  \gdef\rcsfilefname{#4}%
  \gdef\rcs@g{#5}%
  \gdef\rcs@pg{#6}%
}

\def\rcs@popfilestack{%
  \ifx\rcs@filestack\empty
    \PackageWarning{rcs-multi}{Underflow of file keyword stack!}%
  \else
    \rcs@ifequal{\rcs@filestack}{{}}%
      {\PackageWarning{rcs-multi}{Underflow of file keyword stack!}}%
      {\expandafter\rcs@restorefilekws\rcs@filestack\relax}%
  \fi
}

\rcsmulti@atbegininputfile{%
  \rcs@pushfilestack
}

\rcsmulti@atendinputfile{%
  \rcs@popfilestack
}%
%
%    \end{macrocode}

%    \begin{macrocode}
\fi
%    \end{macrocode}

% \subsection{Keyword Group Macros}
% These macros implement the user interface for the keyword group functionality
% introduced with v2.0.
%
% The list of keyword groups |\rcs@glist| is initial set empty and will be
% filled by \cs{rcsgroup}.
%    \begin{macrocode}
\if@rcsmulti@groups
\let\rcs@glist=\empty
%    \end{macrocode}

% \begin{macro}{\rcsgroup}[1]{group name}
% Saves the group to |\rcs@g| and initiates |\rcs@g@|\meta{group name}|@rev|
% and |\@rcs@g@|\meta{group name}|@rev| if this is the first time the group
% got used.\par
% The current group symbol `|*|' is invalid here because there is no way to
% change to a current group.
%    \begin{macrocode}
\def\rcsgroup#1{%
  \rcs@ifequal{#1}{*}%
    {\PackageError{rcs-multi}%
      {The group name '*' is invalid for '\string\rcsgroup'}{}{}%
    }{}%
  \xdef\rcs@g{#1}%
  \let\rcs@pg\rcs@g
  \ifx\rcs@g\empty\else%
%    \end{macrocode}
% Only initialise the group at first usage:
%    \begin{macrocode}
    \expandafter
    \ifx\csname @rcsg@\rcs@g @rev\endcsname\relax%
      \rcs@initgroup{\rcs@g}%
%    \end{macrocode}
% Now save new group to list. The list is checked if its empty to avoid an
% unwanted leading comma.
%    \begin{macrocode}
      \ifx\rcs@glist\empty
        \xdef\rcs@glist{#1}%
      \else
        \xdef\rcs@glist{\rcs@glist,#1}%
      \fi
    \fi
  \fi
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\thercsgroup}
% Returns the current group name to the user.
%    \begin{macrocode}
\def\thercsgroup{\rcs@g}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcssetcg}[1]{group name}
% Defines |\rcs@cg| to the given argument or to |\rcs@g| if the argument was
% `|*|'.
%    \begin{macrocode}
\def\rcssetcg#1{%
  \rcs@ifequal{#1}{*}%
    {\def\rcs@cg{\rcs@g}}%
    {\def\rcs@cg{#1}}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcscg@def}[1]{key name, \eg `rev', `date'}
% Defines a |\rcscgXXX| macro, \eg |rcscgrev|, which returns the
% requested keyword values of the current keyword group.
%    \begin{macrocode}
\def\rcscg@def#1{%
  \expandafter
  \def\csname rcscg#1\endcsname{%
    \@ifundefined{rcsg@\rcs@cg @#1}{??}{%
    \csname rcsg@\rcs@cg @#1\endcsname}%
  }%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcscgrev}
% \begin{macro}{\rcscgdate}
% \begin{macro}{\rcscgauthor}
% \begin{macro}{\rcscgyear}
% \begin{macro}{\rcscgmonth}
% \begin{macro}{\rcscgday}
% \begin{macro}{\rcscghour}
% \begin{macro}{\rcscgminute}
% \begin{macro}{\rcscgsecond}
% \begin{macro}{\rcscgtimezonehour}
% \begin{macro}{\rcscgtimezoneminute}
% \begin{macro}{\rcscgurl}
% \begin{macro}{\rcscgfname}
% Define all |\rcscgXXX| macros by calling \cs{rcscg@def} in a for loop.
%    \begin{macrocode}
\@for\@tempa:=%
  rev,author,date,year,month,day,hour,minute,second,%
  timezonehour,timezoneminute,url,fname%
\do{%
  \expandafter\rcscg@def\expandafter{\@tempa}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

% \begin{macro}{\thercscg}
% Simply return the internal macro.
%    \begin{macrocode}
\def\thercscg{\rcs@cg}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsg}[2]{group name}{keyword name}
% Simply returns |rcsg@#1@#2| if defined, '??' otherwise.
%    \begin{macrocode}
\def\rcsg#1#2{%
  \@ifundefined{rcsg@\rcs@temp @#2}%
    {??}%
    {\csname rcsg@\rcs@temp @#2\endcsname}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@addfiletogroup}[2]{file name}{group name}
% Adds the given file to the given group. If the group list doesn't exist yet
% it is initialised. A extra macro for each file is used to remember that the
% file is already in the group. This could be avoided using a list search.\par
% This is an internal macro so no `|*|' substitution for the group name.
%    \begin{macrocode}
\def\rcs@addfiletogroup#1#2{%
  \expandafter
  \ifx\csname @rcsg@#2@files@#1\endcsname\relax%
    \expandafter\gdef\csname @rcsg@#2@files@#1\endcsname{1}%
    %
    \@ifundefined{@rcsg@#2@files}%
      {\expandafter\xdef\csname @rcsg@#2@files\endcsname{#1}}%
      {\expandafter\xdef\csname @rcsg@#2@files\endcsname{%
        \csname @rcsg@#2@files\endcsname,#1%
       }%
      }%
  \fi
}
%    \end{macrocode}
% \end{macro}

% The input files are added to the list of the current group at their begin to
% have them before the included graphics and other external files.
% Special care is taken to not re-initialise the main file which could happen in
% some special cases (\eg |\lstinputlisting{\jobname .tex}|).
%    \begin{macrocode}
\rcsmulti@atbegininputfile{%
  \rcs@ifequal{\rcs@filepath}{\rcs@maindir\jobname.\rcs@mainext}%
    {}%
    {\rcs@initfile}%
  \rcs@ifequal{\rcs@fileext}{\rcs@mainext}%
    {\rcs@addfiletogroup{\rcs@filedir\rcs@filebase}{\rcs@pg}}{}%
  \rcs@ifequal{\rcs@fileext}{sty}%
    {\rcs@addfiletogroup{\rcs@filedir\rcs@filebase}{\rcs@pg}}{}%
  \rcs@ifequal{\rcs@fileext}{cls}%
    {\rcs@addfiletogroup{\rcs@filedir\rcs@filebase}{\rcs@pg}}{}%
  \rcs@addfiletogroup{\rcs@filepath}{\rcs@filedir\rcs@filebase}%
}
%    \end{macrocode}

% \begin{macro}{\rcs@writegroup}[1]{group name}
% Writes group to |\rcs@write| file.
%    \begin{macrocode}
\def\rcs@writegroup#1{%
  \def\rcs@writekw##1{%
   \immediate\write\rcs@write{%
     \noexpand\@namedef{rcsg@#1@##1}{\csname @rcsg@#1@##1\endcsname}%
   }%
  }%
  \rcs@writekw{rev}%
  \rcs@writekw{date}%
  \rcs@writekw{author}%
  \rcs@writekw{year}%
  \rcs@writekw{month}%
  \rcs@writekw{day}%
  \rcs@writekw{hour}%
  \rcs@writekw{minute}%
  \rcs@writekw{second}%
  \rcs@writekw{timezonehour}%
  \rcs@writekw{timezoneminute}%
  \@ifundefined{@rcsg@#1@files}{}{%
    \immediate\write\rcs@write{%
      \noexpand
      \rcs@namegdefverb{rcsg@#1@files}{\csname @rcsg@#1@files\endcsname}%
    }%
  }%
  \immediate\write\rcs@write{%
    \noexpand
    \rcs@namegdefverb{rcsg@#1@url}{\csname @rcsg@#1@url\endcsname}^^J%
    \noexpand
    \rcs@namegdefverb{rcsg@#1@fname}{\csname @rcsg@#1@fname\endcsname}^^J%
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rcs@writeallgroups}[1]{macro holding a list of groups}
%    \begin{macrocode}
\def\rcs@writeallgroups#1{%
  \begingroup
    \ifx\relax#1\relax\else
      \@for\rcs@temp:=#1\do{%
        \rcs@ifvalidrev{@rcsg@\rcs@temp @rev}%
          {%
            \expandafter
            \rcs@cleanfilelist\csname @rcsg@\rcs@temp @files\endcsname
            \rcs@writegroup{\rcs@temp}%
            \@ifundefined{@rcsg@\rcs@temp @files}{}%
              {\expandafter\rcs@writeallgroups
               \csname @rcsg@\rcs@temp @files\endcsname
              }%
          }{}%
      }%
    \fi
  \endgroup
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@updategroup}[1]{group name}
% Updates group with |\rcsfile...| macro values.
%    \begin{macrocode}
\def\rcs@updategroup#1{%
  \@ifundefined{@rcsg@#1@rev}%
    {\rcs@initgroup{#1}}%
    {}%
  \expandafter
  \ifnum\csname @rcsg@#1@rev\endcsname<\rcsfilerev
    \rcs@gkwset{#1}{rev}{\rcsfilerev}%
    \rcs@gkwset{#1}{date}{\rcsfiledate}%
    \rcs@gkwset{#1}{author}{\rcsfileauthor}%
    \rcs@gkwset{#1}{year}{\rcsfileyear}%
    \rcs@gkwset{#1}{month}{\rcsfilemonth}%
    \rcs@gkwset{#1}{day}{\rcsfileday}%
    \rcs@gkwset{#1}{hour}{\rcsfilehour}%
    \rcs@gkwset{#1}{minute}{\rcsfileminute}%
    \rcs@gkwset{#1}{second}{\rcsfilesecond}%
    \rcs@gkwset{#1}{timezonehour}{\rcsfiletimezonehour}%
    \rcs@gkwset{#1}{timezoneminute}{\rcsfiletimezoneminute}%
    \rcs@gkwset{#1}{url}{\rcsfileurl}%
    \rcs@gkwset{#1}{fname}{\rcsfilefname}%
  \fi
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@definegroup}[1]{group name}
% Defines group value so that they are available for the user, e.g. instead of
% the internal |@rcsg@...| macros it sets the |rcsg@...| macros.
% This is done by calling \cs{rcs@updategroup} with a modified version of
% \cs{rcs@gkwset}.
%    \begin{macrocode}
\def\rcs@definegroup#1{%
  \rcs@gkwdef{#1}{rev}%
  \rcs@gkwdef{#1}{date}%
  \rcs@gkwdef{#1}{author}%
  \rcs@gkwdef{#1}{year}%
  \rcs@gkwdef{#1}{month}%
  \rcs@gkwdef{#1}{day}%
  \rcs@gkwdef{#1}{hour}%
  \rcs@gkwdef{#1}{minute}%
  \rcs@gkwdef{#1}{second}%
  \rcs@gkwdef{#1}{timezonehour}%
  \rcs@gkwdef{#1}{timezoneminute}%
  \rcs@gkwdef{#1}{url}%
  \rcs@gkwdef{#1}{fname}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@initgroup}[1]{group name}
% Initialises group.
%    \begin{macrocode}
\def\rcs@initgroup#1{%
  \rcs@gkwset{#1}{rev}{-1}%
  \rcs@gkwset{#1}{date}{}%
  \rcs@gkwset{#1}{author}{}%
  \rcs@gkwset{#1}{year}{0000}%
  \rcs@gkwset{#1}{month}{00}%
  \rcs@gkwset{#1}{day}{00}%
  \rcs@gkwset{#1}{hour}{00}%
  \rcs@gkwset{#1}{minute}{00}%
  \rcs@gkwset{#1}{second}{00}%
  \rcs@gkwset{#1}{timezonehour}{+00}%
  \rcs@gkwset{#1}{timezoneminute}{00}%
  \rcs@gkwset{#1}{url}{}%
  \rcs@gkwset{#1}{fname}{}%
}
%    \end{macrocode}
% \end{macro}


% \begin{macro}{\rcs@gkwset}[3]{group name}{keyword name}{value}
% Sets \meta{value} for \meta{keyword} in \meta{group}.
%    \begin{macrocode}
\def\rcs@gkwset#1#2#3{%
  \expandafter
  \xdef\csname @rcsg@#1@#2\endcsname{#3}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@gkwdef}[2]{group name}{keyword name}
% Defines |rcsg@...| macros used by the user macros to the value of the
% internal |@rcsg@...| macros.
%    \begin{macrocode}
\def\rcs@gkwdef#1#2{%
  \expandafter
  \xdef\csname rcsg@#1@#2\endcsname{\csname @rcsg@#1@#2\endcsname}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@cleanfilelist}[1]{macro holing a file list}
% Takes a macro which holds a file list and removes all files from the list 
% which don't have a valid revision number.
%    \begin{macrocode}
\def\rcs@cleanfilelist#1{
  \begingroup
    \def\rcs@tmplist{}%
    \ifx\relax#1\relax\else
      \@for\rcs@temp:=#1\do{%
        \expandafter\rcs@ifvalidrev
        \expandafter{@rcsg@\rcs@temp @rev}%
          {\edef\rcs@tmplist{\rcs@tmplist,\rcs@temp}}%
          {}%
      }%
      \xdef#1{\expandafter\@gobble\rcs@tmplist\empty}%
    \fi
  \endgroup
}
%    \end{macrocode}
% \end{macro}

%    \begin{macrocode}
\fi
%    \end{macrocode}

% \subsection{Files as extra groups}
% Macros which allow single files to be declared as extra groups so that their
% keywords can be accessed in the whole document like with normal groups.
% This special groups are not added to the list of groups.

% A user-level switch is declared to enable or disable the automatic declaration
% of every file as own group. This causes \cs{rcssubgroup} to be called for
% all input files.
% The if macro is defined outside the |\if@rcsmulti@subgroups| because
% |\newif| inside |\if| is not a good idea.
%    \begin{macrocode}
\newif\ifrcssubgroups
\rcssubgroupsfalse
%    \end{macrocode}

%    \begin{macrocode}
\if@rcsmulti@subgroups
\rcssubgroupstrue
%    \end{macrocode}

% \begin{macro}{\rcssubgroup}
% User level and internal macro to declare the current file as extra group.
% It produces the current file path and calls \cs{rcs@subgroup}.
% Creates two groups one with and one without the file extension. The one
% without holds the latest revision of all files included in this file.
%    \begin{macrocode}
\def\rcssubgroup{%
  \begingroup
    \rcs@removedotslash\rcs@filedir
    \rcs@subgroup{\rcs@filedir\rcs@filebase}%
    \rcs@subgroup{\rcs@filepath}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@subgroup}[1]{file name}
% Macro to write a file as group to |.rcs| file. After checking if the filename
% was not already written, the |.rcs| file is checked if it is open and then the
% file keyword information is written.
%    \begin{macrocode}
\def\rcs@subgroup#1{%
  \ifnum\rcsfilerev>-1\relax
    \expandafter\ifx\csname rcs@g@#1\endcsname\relax%
      \expandafter\gdef\csname rcs@g@#1\endcsname{1}%
      \rcs@updategroup{#1}%
    \fi
  \fi
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsignoreextensions}[1]{A comma separated list of file name
% extensions (without leading dot) to ignore for automatic \csd{rcssubgroup}.}
% A special macro is defined for all extensions. The existents of this macro is
% then tested later to check if this extension should be ignored.
%    \begin{macrocode}
\def\rcsignoreextensions#1{%
  \@for\rcs@temp:=#1\do{%
    \expandafter\def\csname rcs@ignore@ext@\rcs@temp\endcsname{}%
  }%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsconsiderextensions}[1]{A comma separated list of file name
% extensions (without leading dot) to consider for automatic
% \csd{rcssubgroup}.}
% The special macro defined by \csi{rcsignoreextentions} is deleted, i.e. |\let|
% to |\relax|.
%    \begin{macrocode}
\def\rcsconsiderextensions#1{%
  \@for\rcs@temp:=#1\do{%
  \expandafter\let\csname rcs@ignore@ext@\rcs@temp\endcsname\relax%
  }%
}
%    \end{macrocode}
% \end{macro}

% The following extensions are ignored by default.
%    \begin{macrocode}
\rcsignoreextensions{aux,bbl,cfg,cls,fd,enc,fls,glo,idx,ilg,ind,ist,%
lof,log,lot,out,sty,rcs,svt,svx,toc}
%    \end{macrocode}

% Check at the end of every input file if files should be extra groups and
% declare this file as group if its extension is not configured to be ignored.
%    \begin{macrocode}
\rcsmulti@atendinputfile{%
  \if@rcsmulti@subgroups
    \ifrcssubgroups
      \expandafter\ifx\csname rcs@ignore@ext@\rcs@fileext\endcsname\relax
      \rcssubgroup
      \fi
    \fi
  \fi
}
%    \end{macrocode}

%    \begin{macrocode}
\AtBeginDocument{%
  \if@rcsmulti@subgroups
    \ifrcssubgroups
      \rcs@addfiletogroup{\jobname .\rcs@mainext}{\jobname}%
      \rcssubgroup
    \fi
  \fi
}
%    \end{macrocode}

%    \begin{macrocode}
\fi
%    \end{macrocode}

% \subsection{External Files}
% Macros to declare external files and load the keywords from |.svx| files
% generated by \scr{rcs-multi.pl}.
%    \begin{macrocode}
\if@rcsmulti@external
%    \end{macrocode}

% \begin{macro}{\rcsexternalgroup}[1]{group name}
% Defines the default group of external files. The default is to always use the
% current group.  An empty argument puts the external files in no group. A `|*|'
% switches back to always use the current group.
%    \begin{macrocode}
\if@rcsmulti@groups
\def\rcsexternalgroup#1{%
  \rcs@ifequal{#1}{*}%
    {\def\rcs@externalgroup{#1}}%
    {\def\rcs@externalgroup{\rcs@g}}%
}
\def\rcs@externalgroup{\rcs@g}
\else
\def\rcs@externalgroup{}
\fi
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsexternal}[2]{group name}{list of filenames in \texttt{\{ \}}}
% Writes the current input file path and its argument as arguments of
% \cs{@rcsexternal} into the |.rcs| file.
%    \begin{macrocode}
\newcommand*\rcsexternal[2][]{%
  \if@filesw
    \rcs@checkwrite
    \begingroup
      \rcs@ifequal{#1}{*}%
        {\def\rcs@temp{\rcs@g}}%
        {\rcs@ifempty{#1}%
          {\def\rcs@temp{\rcs@externalgroup}}%
          {\def\rcs@temp{#1}}%
        }%
      \immediate\write\rcs@write{%
        \noexpand\@rcsexternal[\rcs@temp]{\rcs@filepath}{#2}%
      }%
    \endgroup
  \fi
  \rcs@inputsvx{\rcs@filedir\rcs@filebase}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsexternalpath}[1]{list of paths in \texttt{\{ \}}}
% Writes its argument as argument of \cs{@rcsexternalpath} into the |.rcs| file.
%    \begin{macrocode}
\def\rcsexternalpath#1{%
  \if@filesw
    \rcs@checkwrite
    \immediate\write\rcs@write{%
      \noexpand\@rcsexternalpath{#1}%
    }%
  \fi
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\@rcsexternal}
% \begin{macro}{\@rcsexternalpath}
% Discards the argument(s). These macros and their arguments are only used by
% the external \scr{rcs-multi.pl} script.
%    \begin{macrocode}
\newcommand*\@rcsexternal[3][]{}
\def\@rcsexternalpath#1{}
%    \end{macrocode}
% \end{macro}
% \end{macro}


% \begin{macro}{\rcsexternalfile}
% This macro is generated by \scr{rcs-multi.pl} and should not be used by the
% user.  If files-as-group is enabled some special characters are disabled and
% the \cs{rcs@externalfile} is called to read the file name. Otherwise the
% argument is simply removed.
%    \begin{macrocode}
\newcommand*\rcsexternalfile[1][\rcs@filedir\rcs@filebase]{%
  \begingroup % TODO: maybe use \rcs@catcodes
    \catcode`\_=12
    \catcode`\&=12
    \catcode`\^=12
    \catcode`\$=12
    \catcode`\#=12
    \rcs@externalfile{#1}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@externalfile}[2]{group name}{file name}
% Ends group which began in \cs{rcsexternalfile} and calls the appropriate
% macros.
%    \begin{macrocode}
\def\rcs@externalfile#1#2{%
  \endgroup
  \if@rcsmulti@subgroups
    \ifrcssubgroups
      \rcs@ifequal{#1}{\rcs@rg}%
        {\rcs@addfiletogroup{#2}{\rcs@filedir\rcs@filebase}}%
        {\rcs@addfiletogroup{#2}{#1}}%
      \rcs@subgroup{#2}%
    \fi
  \fi
}
%    \end{macrocode}
% \end{macro}

% If \op{external} option is not enabled a placeholder macro is defined which
% simply ignores its argument.
%    \begin{macrocode}
\else
  \def\rcsexternalfile#1{}%
\fi
%    \end{macrocode}


% \subsection{Auto loading of \texttt{.svx} files}
% Auto loading of |.svx| files at the begin of |\input| or |\include| files
% using the \cs{rcsmulti@atbegininputfile} macro.
% The macros \cs{rcs@addfiletogroup} and \cs{rcssubgroup} are used to do the
% actual work.
%    \begin{macrocode}
\if@rcsmulti@autoload

\rcsmulti@atbegininputfile{%
  \rcs@ifequal{\rcs@fileext}{tex}%
    {\rcs@inputsvx{\rcs@filedir\rcs@filebase}}%
    {}%
}
%    \end{macrocode}

% The main |.svx| is loaded at the end of the package.
%    \begin{macrocode}
%%\AtEndOfPackage{%
\AtBeginDocument{%
  \rcs@inputsvx{\jobname}%
}
%    \end{macrocode}

%    \begin{macrocode}
\fi
%    \end{macrocode}


% \subsection{Support for Graphic Packages}

% \subsubsection{Common Code}
%    \begin{macrocode}
\if@rcsmulti@anygraphic
%    \end{macrocode}

% \begin{macro}{\rcsgraphicsgroup}[1]{graphic group name}
% Defines the default group of graphics files. The default is empty which means
% the current group.
%    \begin{macrocode}
\def\rcsgraphicsgroup#1{%
  \rcs@ifequal{#1}{*}%
    {\def\rcs@graphicsgroup{\rcs@g}}%
    {\def\rcs@graphicsgroup{#1}}%
}
\def\rcs@graphicsgroup{\rcs@externalgroup}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsignoregraphic}[1]{file name/path}
% Ignores the given graphic file by defining a special macro.
%    \begin{macrocode}
\def\rcsignoregraphic#1{%
  \expandafter\def\csname rcs@ignoregraphic@#1\endcsname{}%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsconsidergraphic}[1]{file name/path}
% Deletes the special ignore macro to consider the graphic again.
%    \begin{macrocode}
\def\rcsconsidergraphic#1{%
  \expandafter\let\csname rcs@ignoregraphic@#1\endcsname\relax%
}
%    \end{macrocode}
% \end{macro}

%    \begin{macrocode}
\fi
%    \end{macrocode}

% \subsubsection{Package \texttt{graphics}}
% Automatic declaration of all images included by |\includegraphics| from the
% \pkg{graphics} package as external files. We use the |\Gin@setfile| macro from
% that package which receives the image file name as third argument.
%    \begin{macrocode}
\if@rcsmulti@graphics
\RequirePackage{graphics}[2006/02/20]
%    \end{macrocode}

% \begin{macro}{\Gin@setfile}[3]{??, not used}{??, not used}{graphic file
% name/path}
%    \begin{macrocode}
\message{Package rcs-multi: patching macro '\string\Gin@setfile' from the
'graphics' package!}%
\let\rcsmulti@Gin@setfile\Gin@setfile
\renewcommand*{\Gin@setfile}[3]{%
  \expandafter\ifx\csname rcs@ignoregraphic@#3\endcsname\relax%
    \rcsexternal[\rcs@graphicsgroup]{{#3}}%
  \fi
  \rcsmulti@Gin@setfile{#1}{#2}{#3}%
}
%    \end{macrocode}
% \end{macro}

%    \begin{macrocode}
\fi
%    \end{macrocode}

% \subsubsection{Package \texttt{pgf}}
% The \pkg{pgf} macro |\pgf@declareimage| which is called by the user macro
% |\pgfdeclareimage| is used.
%    \begin{macrocode}
\if@rcsmulti@pgfimages
\RequirePackage{pgf}[2008/01/15]
%    \end{macrocode}

% \begin{macro}{\pgf@declareimage}[3]{??, not used}{image label}{??, not used}
%    \begin{macrocode}
\message{Package rcs-multi: patching macro '\string\pgf@declareimage' and will
patch generated macros '\string\pgf@image@<name>!' from the 'pgf' package!}%
\let\rcsmulti@pgf@declareimage\pgf@declareimage
\renewcommand*{\pgf@declareimage}[3][]{%
  \rcsmulti@pgf@declareimage[#1]{#2}{#3}%
%    \end{macrocode}
% At this point the used image filename is defined by |\pgf@filename| and the
% image itself is defined by |\pgf@image@#2!| which is a |\let| copy of
% temporary |\pgf@image|.  An own copy of this is created and the old name
% |\pgf@image@#2!| is used to execute \cs{rcsexternal} every time the image is
% included using |\pgfuseimage|.
% \begin{macrocode}
  \ifx\pgf@filename\empty\else
    \expandafter\ifx\csname rcs@ignoregraphic@\pgf@filename\endcsname\relax%
      \expandafter\global\expandafter%
      \let\csname rcsmulti@pgf@image@#2!\endcsname=\pgf@image%
      \expandafter\xdef\csname pgf@image@#2!\endcsname{%
        \noexpand\rcsexternal[\noexpand\rcs@graphicsgroup]{{\pgf@filename}}%
        \csname rcsmulti@pgf@image@#2!\endcsname
      }%
    \fi
  \fi
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\fi
%    \end{macrocode}
%
% \subsection{Table of Revisions}
%
%    \begin{macrocode}
\if@rcsmulti@table
\ifx\tableofcontents\relax\else
%    \end{macrocode}
%
% \begin{macro}{\rcsrevisionsname}
% Simple definition for now. Language support over `babel's |\languagename|
% possible.
%    \begin{macrocode}
\def\rcsrevisionsname{Table of Revisions}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rcs@svt}
% File ending for table of revision auxiliary file. A macro is used to allow
% redefinition by the user if another package is uses the same ending.
%    \begin{macrocode}
\def\rcs@svt{svt}
%    \end{macrocode}
% \end{macro}
%

% \begin{macro}{\tableofrevisions}
% The |\tableofcontents| macro from standard \LaTeX\ is adapted for this macro.
% Classes which provide chapters will get a different table then one which not.
%    \begin{macrocode}
\AtBeginDocument{%
\ifx\chapter\@undefined

%% Adapted from the \tableofcontents macro, LaTeX `article' class [2005/09/16]
\newcommand\tableofrevisions{%
  \section*{\rcsrevisionsname
  \@mkboth{\MakeUppercase\rcsrevisionsname}{\MakeUppercase\rcsrevisionsname}}%
  \rcs@input{\jobname .\rcs@svt}%
}

\else

%% Adapted from the \tableofcontents macro, LaTeX `book' class [2005/09/16]
\newcommand\tableofrevisions{%
  \if@twocolumn
    \@restonecoltrue\onecolumn
  \else
    \@restonecolfalse
  \fi
  \chapter*{\rcsrevisionsname
    \@mkboth{\MakeUppercase\rcsrevisionsname}{\MakeUppercase\rcsrevisionsname}}%
  \rcs@input{\jobname .\rcs@svt}%
  \if@restonecol\twocolumn\fi
}

\fi
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\fi % defined \tableofcontents
%    \end{macrocode}

% \begin{macro}{\rcs@writerow}[3]{row type ('group', 'file', 'global', \ldots)}
% {row type specific argument}{row type specific argument}
% Writes a table row by using |\rcs@tabcell| and |\rcs@tabcellarg| defined by
% the |\rcs@writeXXXrow| macro below.
%    \begin{macrocode}
\def\rcs@writerow#1#2#3{%
  \immediate\write\rcs@svtwrite{%
    \expandafter\noexpand\csname rcs#1row\endcsname
    \expandafter\noexpand\csname rcstab#1\endcsname{#2}{#3}\space
    \@ampersamchar\space
    \rcs@tabcell{rev}\space\@ampersamchar\space
    \rcs@tabcell{author}\space\@ampersamchar\space
    \noexpand\rcstabdate%
    \rcs@tabcellarg{year}%
    \rcs@tabcellarg{month}%
    \rcs@tabcellarg{day}%
    \rcs@tabcellarg{hour}%
    \rcs@tabcellarg{minute}%
    \rcs@tabcellarg{second}%
    \rcs@tabcellarg{timezonehour}%
    \rcs@tabcellarg{timezoneminute}%
    \space\@backslashchar\@backslashchar
    \expandafter\noexpand\csname endrcs#1row\endcsname
  }%
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@writegrouprow}[1]{current group}
%    \begin{macrocode}
\def\rcs@writegrouprow#1{%
  \begingroup
    \def\rcs@tabcellarg##1{{\csname @rcsg@#1@##1\endcsname}}%
    \def\rcs@tabcell##1{\expandafter\noexpand\csname rcstab##1\endcsname%
      \rcs@tabcellarg{##1}%
    }%
    \rcs@writerow{group}{#1}{}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@writesubgrouprow}[2]{grouping level}{subgroup name}
%    \begin{macrocode}
\def\rcs@writesubgrouprow#1#2{%
  \begingroup
    \def\rcs@tabcellarg##1{{\csname @rcsg@#2@##1\endcsname}}%
    \def\rcs@tabcell##1{\expandafter\noexpand\csname rcstab##1\endcsname%
      \rcs@tabcellarg{##1}%
    }%
    \rcs@writerow{subgroup}{#1}{#2}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@writefilerow}[2]{grouping level}{file name}
%    \begin{macrocode}
\def\rcs@writefilerow#1#2{%
  \begingroup
    \def\rcs@tabcellarg##1{{\csname @rcsg@#2@##1\endcsname}}%
    \def\rcs@tabcell##1{\expandafter\noexpand\csname rcstab##1\endcsname%
      \rcs@tabcellarg{##1}%
    }%
    \rcs@writerow{file}{#1}{#2}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@writeglobalrow}
%    \begin{macrocode}
\def\rcs@writeglobalrow{%
  \begingroup
  \def\rcs@tabcellarg##1{{\csname @rcs@##1\endcsname}}%
  \def\rcs@tabcell##1{\expandafter\noexpand\csname rcstab##1\endcsname%
    \rcs@tabcellarg{##1}%
  }%
  \rcs@writerow{global}{}{}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}

% \subsubsection{Table Format Macros}\label{sec:impl:table}
% Generic format macro used in the |.svt| file. Can be redefined by the user to
% change table format. % TODO: More documentation needed!
%
% \begin{macro}{\rcstable}
%    \begin{macrocode}
\def\rcstable{%
  \begin{tabular}{p{0.425\textwidth}rp{0.25\textwidth}p{0.225\textwidth}}%
    \hline
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endrcstable}
%    \begin{macrocode}
\def\endrcstable{\hline\end{tabular}}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcstablehead}
%    \begin{macrocode}
\def\rcstablehead{%
    Name & Rev & Last Author & Last Changed At \\\hline
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcstablefoot}
%    \begin{macrocode}
\def\rcstablefoot{}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsbeforetable}
%    \begin{macrocode}
\def\rcsbeforetable{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcsaftertable}
%    \begin{macrocode}
\def\rcsaftertable{\clearpage}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcsglobalrow}
%    \begin{macrocode}
\def\rcsglobalrow{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endrcsglobalrow}
%    \begin{macrocode}
\def\endrcsglobalrow{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcsgrouprow}
%    \begin{macrocode}
\def\rcsgrouprow{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endrcsgrouprow}
%    \begin{macrocode}
\def\endrcsgrouprow{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcssubgrouprow}
%    \begin{macrocode}
\def\rcssubgrouprow{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endrcssubgrouprow}
%    \begin{macrocode}
\def\endrcssubgrouprow{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcssubgrouprow}
%    \begin{macrocode}
\def\rcsfilerow{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endrcsfilerow}
%    \begin{macrocode}
\def\endrcsfilerow{}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcstabglobal}
%    \begin{macrocode}
\def\rcstabglobal{Document}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcstabgroup}
%    \begin{macrocode}
\def\rcstabgroup#1{Group `#1'}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcstabfile}
%    \begin{macrocode}
\def\rcstabsubgroup#1{%
  \raggedright
  \addtolength{\leftskip}{#1\medskipamount}%
  \begingroup
  \catcode`\_=12
  \catcode`\&=12
  \catcode`\^=12
  \catcode`\$=12
  \catcode`\#=12
  \rcs@tabsubgroup
}
\def\rcs@tabsubgroup#1{\endgroup Subgroup `\texttt{\small #1}'}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcstabfile}
%    \begin{macrocode}
\def\rcstabfile#1{%
  \raggedright
  \addtolength{\leftskip}{#1\medskipamount}%
  \begingroup
  \catcode`\_=12
  \catcode`\&=12
  \catcode`\^=12
  \catcode`\$=12
  \catcode`\#=12
  \rcs@tabfile
}
\def\rcs@tabfile#1{\endgroup File `\texttt{\small #1}'}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcstabrev}
%    \begin{macrocode}
\def\rcstabrev{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcstabauthor}
%    \begin{macrocode}
\def\rcstabauthor#1{\rcsFullAuthor{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\rcstabdate}
%    \begin{macrocode}
\def\rcstabdate#1#2#3#4#5#6#7#8{%
    #1-#2-#3 #4:#5:#6% #7#8%
}
%    \end{macrocode}
% \end{macro}

%    \begin{macrocode}
\fi
%    \end{macrocode}
%

% \subsection{Other macros}
% This section contains macros which don't fit in any other section.
%
% \begin{macro}{\rcs}
% \begin{macro}{\rcs*}
% After *-testing, the intermediate macros |\rcs@s| and |\rcs@n| are called to
% strip the |{ }| from |\rcs|[|*|]|{$...$}| and to remove the |*|. Then the
% actual macros are called to strip the dollars with or without the space
% before the last dollar.
% \changes{v1.2}{2007/06/22}{Added star version. Normal version was not
% changed to not break existing documents with user defined keywords without
% leading space.}
%    \begin{macrocode}
\newcommand{\rcs}{\@ifnextchar{*}{\rcs@s}{\rcs@n}}
\def\rcs@n#1{\@rcs@n#1}
\def\rcs@s*#1{\@rcs@s#1}
\def\@rcs@n$#1${#1}
\def\@rcs@s$#1 ${#1}
%    \end{macrocode}
% \end{macro}
% \end{macro}

% \begin{macro}{\rcsnolinkurl}[1]{URL}
% This code is taken from the \pkg{hyperref} package and is the definition of
% |\url| just without the part which creates the actual hyperlink. This needs
% of course the \pkg{hyperref} package. A warning is given if it isn't loaded.
% \changes{v1.2}{2007/06/22}{New macro}
%    \begin{macrocode}
%% Adapted from the \url macro of the `hyperref` package.
\DeclareRobustCommand*{\rcsnolinkurl}{%
  \@ifundefined{hyper@normalise}%
    {\PackageWarning{rcs-multi}{Package hyperref is needed for \noexpand
     \rcsnolinkurl.}}%
    {\hyper@normalise\rcsnolinkurl@}%
}%
\def\rcsnolinkurl@#1{\Hurl{#1}}%
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@getfilename}[1]{URL}
% This macro expands the content using the temporary macro and sets it in front
% of the \csi{rcs@getfilename} sub-macro together with |/{}| to make sure the
% macro does not break at values without directories. A |\relax| is used as
% end marker.
%    \begin{macrocode}
\def\rcs@getfilename#1{%
  \begingroup
    \edef\rcs@temp{#1}%
    \expandafter\@rcs@getfilename\rcs@temp/{}\relax
}%
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\@rcs@getfilename}[2]{URL part before first slash}{URL part after
% first slash}
% Splits the content at the first slash (|/|) and checks if the remainder is
% empty. If so the end marker got reached and the part before the slash is the
% filename which is returned. Otherwise the macro recursively calls itself to
% split the remainder.
%    \begin{macrocode}
\def\@rcs@getfilename#1/#2\relax{%
    \rcs@ifempty{#2}%
      {\endgroup\gdef\rcsfilefname{#1}}%
      {\@rcs@getfilename#2\relax}%
}%
%    \end{macrocode}
% \end{macro}

% \subsection{Auxiliary file generation and read-back}
%
% Reread output from last compile run if it exists.
%    \begin{macrocode}
\@input{\jobname .rcs}
%    \end{macrocode}

% \begin{macro}{\rcs@checkwrite}
% Checks if .rcs file is already open and if not opens it. This makes sure that
% the file is only created if really needed. The macro is only needed once, so
% it's redefines itself to |\relax| at the end.
%    \begin{macrocode}
\def\rcs@checkwrite{%
 \@ifundefined{rcs@write}{%
   \newwrite\rcs@write
   \immediate\openout\rcs@write=\jobname.rcs\relax%
   \immediate\write\rcs@write{\@percentchar\space SVN Keyword cache}%
   %\immediate\write\rcs@write{\noexpand\makeatletter}%
 }{}%
 \let\rcs@checkwrite=\relax
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\rcs@writercs}
% This macro writes the |.rcs| auxiliary file and is called from a
% |\AtEndDocument| macro later on.
%    \begin{macrocode}
{\catcode`\&=12
\gdef\@ampersamchar{&}
}
\def\rcs@writercs{%
%    \end{macrocode}
% Remove all files which do not have a revision number from list:
%    \begin{macrocode}
    \if@rcsmulti@groups
    \fi
%    \end{macrocode}
% Write document global values:
%    \begin{macrocode}
    \rcs@checkwrite
    \immediate\write\rcs@write{^^J%
      \@percentchar\space Global values:^^J%
      \noexpand\def\noexpand\rcsrev{\@rcs@rev}^^J%
      \noexpand\def\noexpand\rcsdate{\@rcs@date}^^J%
      \noexpand\def\noexpand\rcsauthor{\@rcs@author}^^J%
      \noexpand\def\noexpand\rcsyear{\@rcs@year}^^J%
      \noexpand\def\noexpand\rcsmonth{\@rcs@month}^^J%
      \noexpand\def\noexpand\rcsday{\@rcs@day}^^J%
      \noexpand\def\noexpand\rcshour{\@rcs@hour}^^J%
      \noexpand\def\noexpand\rcsminute{\@rcs@minute}^^J%
      \noexpand\def\noexpand\rcssecond{\@rcs@second}^^J%
      \noexpand\def\noexpand\rcstimezonehour{\@rcs@timezonehour}^^J%
      \noexpand\def\noexpand\rcstimezoneminute{\@rcs@timezoneminute}^^J%
      \noexpand\rcs@gdefverb\noexpand\rcsurl{\@rcs@url}^^J%
      \noexpand\rcs@gdefverb\noexpand\rcsfname{\@rcs@fname}^^J%
    }%
%    \end{macrocode}
% Write group keyword macro definitions.
% Remove all files which do not have a revision number from list:
%    \begin{macrocode}
    \if@rcsmulti@groups
      \rcs@cleanfilelist\@rcsg@@files
      \immediate\write\rcs@write{%
        \noexpand\def\noexpand\rcsg@@files{\@rcsg@@files}^^J%
      }%
      \rcs@writeallgroups\@rcsg@@files
%    \end{macrocode}
% Write keyword group values if groups were specified:
%    \begin{macrocode}
      \ifx\rcs@glist\empty\else
        \begingroup
          \immediate\write\rcs@write{^^J%
            \@percentchar\space SVN File Groups: \rcs@glist
          }%
          \rcs@writeallgroups\rcs@glist
        \endgroup
      \fi
    \else
      \immediate\write\rcs@write{^^J}%
    \fi
%    \end{macrocode}
% Finally close output file:
%    \begin{macrocode}
    \immediate\closeout\rcs@write%
}
%    \end{macrocode}
% \end{macro}


% \begin{macro}{\rcs@writegroupfiles}[1]{group name}
% Writes all files of a group to the |.svt| file. If the file is actually a
% subgroup it calls itself recursively.
%    \begin{macrocode}
\def\rcs@writegroupfiles#1{%
  \begingroup
    \advance\rcs@grouplevel by 1\relax
    \expandafter\let
    \expandafter\rcs@files\csname @rcsg@#1@files\endcsname
    \ifx\rcs@files\relax\else
      \rcs@cleanfilelist\rcs@files
      \@for\rcs@file:=\rcs@files\do{%
        \rcs@ifvalidrev{@rcsg@\rcs@file @rev}%
          {%
            \@ifundefined{@rcsg@\rcs@file @files}%
              {\rcs@writefilerow{\the\rcs@grouplevel}{\rcs@file}}%
              {\rcs@ifequal{\csname @rcsg@\rcs@file @files\endcsname}{\rcs@file.tex}%
                {\rcs@writefilerow{\the\rcs@grouplevel}{\rcs@file.tex}}%
                {%
                  \rcs@writesubgrouprow{\the\rcs@grouplevel}{\rcs@file}%
                  \rcs@writegroupfiles{\rcs@file}%
                }%
              }%
          }{}%
      }%
    \fi
  \endgroup
}%
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\rcs@writesvt}
% This macro writes the |.svt| auxiliary file and is called from a
% |\AtEndDocument| macro later on.
%    \begin{macrocode}
\def\rcs@writesvt{%
%    \end{macrocode}
% Write table of revisions if enabled.
%    \begin{macrocode}
  \if@rcsmulti@table
%    \end{macrocode}
% Open |.svt| file and write table header:
%    \begin{macrocode}
    \newwrite\rcs@svtwrite
    \immediate\openout\rcs@svtwrite=\jobname.\rcs@svt\relax
    \@onelevel@sanitize\rcstable%
    \immediate\write\rcs@svtwrite{%
      \noexpand\rcsbeforetable^^J%
      \rcstable
      \noexpand\rcstablehead^^J%
    }%
%    \end{macrocode}
% Group rows:
%    \begin{macrocode}
    \let\rcs@grouplevel\@tempcnta
    \rcs@grouplevel=0\relax
    \rcs@writeglobalrow{}%
    \rcs@writegroupfiles{}%
%
    \@for\rcs@g:=\rcs@glist\do{%
      \@ifundefined{@rcsg@\rcs@g @rev}{}%
      {%
        \expandafter
        \ifnum\csname @rcsg@\rcs@g @rev\endcsname>0\relax
          \rcs@writegrouprow{\rcs@g}%
          \rcs@writegroupfiles{\rcs@g}%
        \fi
      }%
    }%

%    \end{macrocode}
% Write table footer and close file:
%    \begin{macrocode}
    \@onelevel@sanitize\endrcstable%
    \immediate\write\rcs@svtwrite{%
      \noexpand\rcstablefoot^^J%
      \endrcstable^^J%
      \noexpand\rcsaftertable
    }%
    \immediate\closeout\rcs@svtwrite%
  \fi
}
%    \end{macrocode}
% \end{macro}

% At the end of document the values are written to the auxiliary file.
%    \begin{macrocode}
\AtEndDocument{%
  \if@filesw
    \ifx\@rcs@rev\empty\else
      \ifnum\@rcs@rev<1\else
        \rcs@writercs
        \rcs@writesvt
      \fi
    \fi
  \fi
}
%    \end{macrocode}
%
% \subsection{Backward compatibility wrapper \texttt{rcskw.sty}}
% For backward compatibility a wrapper file with the old package name |rcskw| is
% provided. Newer documents should use the name \rcsmulti.
% \setcounter{CodelineNo}{0}
% \iffalse
%</package>
%<*wrapper>
% \fi
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[1999/12/01]
\ProvidesPackage{rcskw}
[\filedate\space\fileversion\space Backward compatibility wrapper for rcs-multi]
\PackageWarning{rcskw}{The package 'rcskw' got renamed to 'rcs-multi'
and is now only a backward compatibility wrapper which loads 'rcs-multi'.
Please adjust your document preamble to use the new name.}
\RequirePackage{rcs-multi}[\filedate]
%    \end{macrocode}
% \iffalse
%</wrapper>
% \fi
%
% \Finale
\endinput
